{
  "version": 1,
  "items": [
    {
      "id": "ques_1",
      "title": "소프트웨어 설계 시 구축된 플랫폼의 성능 특성 분석에 사용되는 측정 항목이 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "응답 시간(Response Time)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "가용성(Availability)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용률(Utilization)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "서버 튜닝(Server Tuning)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "플랫폼 성능 특성 분석은 성능 테스트 (응답 시간, 사용률, 가용성)와 문서 점검, 사용자 인터뷰 등이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_2",
      "title": "플랫폼의 기능이 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "연결 기능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "비용 감소",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "커뮤니케이션",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "기업 비전 수립",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "플랫폼은 구매자와 공급자 연결, 비용 감소, 의사소통, 삼각 프리즘 기능을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_3",
      "title": "플랫폼의 성능 특성 분석 방법으로 맞지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "성능 테스트",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "문서 점검",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자 인터뷰",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "플랫폼의 가격",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "플랫폼의 성능 특성은 성능 테스트, 문서 점검, 사용자 인터뷰로 분석한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_4",
      "title": "플랫폼의 성능 특성 분석 시 세부 사항으로 맞지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "검색 소요 시간 측정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "평균 초당 업로드 데이터양",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "문서 양식 및 내용",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "플랫폼의 구조 측정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "플랫폼의 성능 특성 분석 시 세부 사항에는 성능 테스트, 문서 점검, 사용자 인터뷰 3가지 방법으로 검색 소요 시간 및 평균 업로드 데이터양, 문서 양식, 초당 다운로드 데이터양, 데이터 용량 규격, 제한/보존 기간 등이 반영되었는지를 확인할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_5",
      "title": "운영체제의 목적으로 적합하지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Thoughput 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Turnaround time 단축",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Availability 감소",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Reliabilit 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Availability 감소는 운영체제의 목적에 적합하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_6",
      "title": "운영체제의 고려 사항 중 장기간 시스템을 운영 시 운영체제의 장애 발생 가능성을 고려하는 부분은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "신뢰성 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "성능 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "비용 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "기술 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "장기간 운영 시 고려할 사항은 신뢰성, 비용, 기술 분석입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_7",
      "title": "운영체제의 기능으로 가장 거리가 먼 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "사용자의 편리한 환경 제공",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "처리능력 및 신뢰도 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "컴퓨터 시스템의 성능 최적화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "언어 번역 기능을 통한 실행 가능한 프로그램 생성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "언어 번역 기능은 운영체제가 아니라 컴파일러의 기능입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_8",
      "title": "운영체제의 목적으로 적합하지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Throughput 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Turnaround time 단축",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Availability 감소",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Reliability 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Availability 감소는 운영체제의 목적에 적합하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_9",
      "title": "다음 중 운영체제가 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Prezi",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Windows",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Unix",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Linux",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Prezi는 운영체제가 아닌 프레젠테이션 소프트웨어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_10",
      "title": "운영체제의 역할로 가장 옳지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "사용자 인터페이스 제공",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "입출력에 대한 로드 역할 수행",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자들 간 하드웨어 자원의 공동 사용",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "원시 프로그램을 목적 프로그램으로 변환",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "CPU 스케줄링은 메모리 효율성과 직접 관련이 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_11",
      "title": "현행 시스템 분석 시 운영체제 고려 사항으로 알맞지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "신뢰도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "성능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "기술 지원",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 압축 및 복원",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "FIFO는 먼저 온 작업을 먼저 처리하는 알고리즘입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_12",
      "title": "OSI 7계층에서 TCP는 어떤 계층에 해당되는가?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "세션 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "네트워크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "전송 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 링크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "운영체제의 목적은 자원의 효율적 사용, 사용자 편의성 증진, 안정적 운영입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_13",
      "title": "OSI 7계층 총 통신망을 통해 패킷을 목적지까지 전달하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "응용 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "네트워크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "표현 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "물리 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "배치 작업 처리 시스템은 일괄적으로 작업을 처리합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_14",
      "title": "OSI 7계층 중 네트워크 가상 터미널이 존재하여 서로 상이한 프로토콜에 의해 발생하는 호환성 문제를 해결하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "데이터 링크 계층(data link layer)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "세션 계층(session layer)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "표현 계층(presentation layer)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "응용 계층(application layer)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "응답시간 단축은 성능 향상 측면이며, 안정성과는 다른 개념입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 2
    },
    {
      "id": "ques_15",
      "title": "OSI 7계층에서 네트워크 논리적 어드레싱과 라우팅 기능을 수행하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "2계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "3계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "4계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "성능 측정 항목에 구조 설계 방법은 포함되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_16",
      "title": "OSI 7계층에서 송수신자 간 Logical Address를 지정하고 데이터를 포워딩과 라우팅을 수행할 수 있도록 지원하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "세션 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "네트워크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "전송 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 링크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "OS 장애 대비 항목으로 성능 분석은 적절하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_17",
      "title": "OSI 7계층에서 압축, 암호화 기능을 하며, 응용 계층 간에 전송하는 데이터의 표현을 담당하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "세션 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "네트워크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "전송 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "프레젠테이션 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "언어 번역은 운영체제 기능이 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_18",
      "title": "OSI 7계층에서 계층을 타고 내려온 데이터를 전기적 신호('0'과 '1')로 변환시켜 통신하는 계층은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "물리 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "네트워크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "전송 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 링크 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Throughput 저하는 운영체제의 목적에 적합하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_19",
      "title": "데이터베이스 관리 시스템(DBMS)의 주요 필수 기능과 거리가 먼 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "데이터베이스 구조를 정의할 수 있는 정의 기능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "데이터 사용자의 통제 및 보안 기능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터베이스 내용의 정확성과 안정성을 유지할 수 있는 제어 기능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 조작어로 데이터베이스를 조작할 수 있는 조작 기능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "구글 드라이브는 클라우드 저장소이지 운영체제가 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_20",
      "title": "DBMS(Data Base Management System)의 설명으로 옳지 않은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "종소성과 중복성의 문제를 해결하기 위해서 제안된 시스템이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "데이터 모델링을 수행하고 데이터베이스 스키마를 생성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "응용 프로그램과 데이터의 중재자로 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터베이스의 구성, 접근방법, 관리 유지에 대한 모든 책임을 지고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "페이지 교체 알고리즘은 운영체제의 메모리 관리에 사용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_21",
      "title": "DBMS를 사용했을 때의 장점으로 거리가 먼 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "표준화의 범기관적 시행",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "단순한 에비와 회복 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터의 보안 보장이 용이",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터 무결성 및 일관성 유지",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Time Sharing System은 다수의 사용자가 시스템을 공유하여 사용할 수 있게 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_22",
      "title": "DBMS 분석 시 고려 사항으로 거리가 먼 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "가용성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "성능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "네트워크 구성도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "상호 운용성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "스케줄링 알고리즘은 프로세스 우선순위 설정에 따라 CPU 할당 순서를 결정합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_23",
      "title": "비지니스 용합 분석을 위한 고려 사항이 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "고객 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기업 제품 공급 역량 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "기업의 사업 구조 생산 방식 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "기업의 제품 판매량 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "운영체제의 종류에는 Windows, Linux, Unix 등이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_24",
      "title": "비지니스 융합 분석을 위한 활동이 아닌 것은?\n",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "기업 전략 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기업의 영역 및 방향 설정 분석\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "융합 모델 설계/평가",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "기업의 목표 수립",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "운영체제의 성능 분석 방법에 사용자 인터페이스 설계는 해당하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_25",
      "title": "요구 사항 명세 기법에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "비정형 명세 기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "비정형 명세 기법은 사용자의 요구를 표현할 때 Z 비정형 명세 기법을 사용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "정형 명세 기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "정형 명세 기법은 비정형 명세 기법에 비해 표현이 간결하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "정형 면세 기법에는 Z, VDM, CSP, CCS등의 기법이 존재한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_26",
      "title": "요구 공학의 요구 사항 개발 프로세서 중에 요구 사항을 식별하고 분류하며 우선순위들 설정하는 프로세스는?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "요구 사항 검중",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "요구 사항 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "요구 사항 명세화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "요구 사항 추출",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "요구 사항 개발 추출, 프로세스는 인터뷰, 문서 분석, 프로토타이핑을 통해 요구 사항을 식별하고 분류하며 우선순위를 설정하여 문서화한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_27",
      "title": "요구 사항 개발 프로세서가 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "요구 사항 추출",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "요구 사항 기준선",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "요구 사항 명세화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "요구 사항 검증",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "요구사항 기준선 관리는 요구사항 관리 프로세스이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_28",
      "title": "요구 사항 관리 프로세서가 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "요구 사항 추출",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "요구 사항 기준선",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "요구 사항 변경 관리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "요구 사항 확인 및 검증",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "요구사항 추출은 요구사항 개발 프로세스이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_29",
      "title": "UML 다이어그램 중 순차 다이어그램에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "주로 시스템의 정적 측면을 모델링하기 위해 사용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "회귀 메시지(Self•Message), 제어블록(Statement block) 등으로 구성된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "순차 다이어그램은 동적 상호작용을 나타내므로 정적 모델링과는 거리가 멀다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_30",
      "title": "메시지 지향 미들웨어(MOM)에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "MOM은 비동기 메시징을 기반으로 하며, 안정적인 데이터 전송이 중요하므로 즉각적인 응답이 필요한 환경에는 적합하지 않다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_31",
      "title": "익스트림 프로그래밍에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "대표적인 구조적 방법론 중 하나이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "익스트림 프로그래밍은 구조적 방법론이 아닌 애자일 방법론의 일종입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_32",
      "title": "유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "연관",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "확장",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "구체화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "일반화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "유스케이스 관계에 포함되지 않는 것은 '구체화'입니다. 일반적으로 연관, 확장, 포함, 일반화 등이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_33",
      "title": "요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 비기능적 요구이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "성능이나 응답 시간 등 품질 기준을 나타내므로 비기능적 요구입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_34",
      "title": "정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Package Diagram",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "State Transition Diagram",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Deployment Diagram",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Entity•Relationship Diagram",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "데이터베이스 설계 표현은 Entity•Relationship Diagram(ERD)을 사용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_35",
      "title": "미들웨어(Middleware)에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러 가지 형태로 연결이 가능합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "미들웨어는 내부 동작을 숨기고 서비스를 제공하는 것이 원칙이므로 내부 동작을 쉽게 확인할 필요는 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_36",
      "title": "UI의 설계 지침으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "치명적인 오류는 사용자가 인지할 수 있도록 분명히 알려야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_37",
      "title": "객체지향 개념에서 다형성(Polymorphism)과 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "메소드 오버라이딩은 상위 클래스의 메소드 구현을 하위 클래스에서 무시하고 재정의할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "메소드 오버로딩의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "메소드 오버로딩은 메소드명이 동일하고 매개변수가 다른 경우를 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_38",
      "title": "객체에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "객체는 공통 속성을 공유하는 클래스들의 집합입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "객체의 상태는 속성값에 의해 정의됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "클래스가 공통 속성을 공유하는 객체들의 집합입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_39",
      "title": "속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Inheritance",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Class",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Encapsulation",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Association",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Encapsulation(캡슐화)은 데이터와 연산을 하나로 묶는 개념입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_40",
      "title": "애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "협상과 계약보다는 고객과의 협력을 중시합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "문서 중심이 아닌, 실행 가능한 소프트웨어를 중시합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "애자일은 변화에 빠르게 대응하는 것을 중시합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 3
    },
    {
      "id": "ques_41",
      "title": "인터페이스를 통해서만 접근할 수 있는 독립적이며 재사용 가능한 시스템의 단위는?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Model",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Sheet",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Component",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Cell",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Component는 인터페이스를 통해서 접근 가능한 독립적이고 재사용 가능한 소프트웨어 단위입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_42",
      "title": "GoF 디자인 패턴의 구조 패턴이 아닌 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Adapter 패턴",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Bridge 패턴",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Builder 패턴",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Proxy 패턴",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Builder 패턴은 생성 패턴에 해당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_43",
      "title": "UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Feedback",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Posture",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Module",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Hash",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "사용자의 동작에 대한 시스템의 응답과 진행 상황을 보여주는 것을 Feedback이라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_44",
      "title": "UI의 종류로 멀티 터치, 동작 인식 등 사용자의 자연스러운 움직임을 인식하여 서로 주고받는 정보를 제공하는 사용자 인터페이스는?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "GUI(Graphical User Interface)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "OUI(Organic User Interface)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "NUI(Natural User Interface)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "CLI(Command Line Interface)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "자연스러운 움직임과 직관적인 조작을 지원하는 인터페이스를 NUI라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_45",
      "title": "소프트웨어 모델링과 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구 사항의 결과를 표현합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "객체지향 방법론에서는 UML 표기법을 사용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "모델링 결과물은 다른 모델링 작업에 영향을 줄 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_46",
      "title": "유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "시스템과 상호작용하는 외부시스템은 액터로 파악할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_47",
      "title": "소프트웨어 아키텍처 모델 중 MVC(Model•View•Controller)와 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 설계",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "모델(Model)은 전달자 역할이 아니라 데이터와 비즈니스 로직을 관리합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_48",
      "title": "통합 테스트(Integration Test)와 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "하향식 통합 테스트의 경우 넓이 우선(Breadth First) 방식으로 테스트를 할 모듈을 선택할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식 보다는 하향식 통합 테스트를 사용하는 것이 좋다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "상향식 통합 테스트는 시스템 구조의 최하위 모듈부터 테스트를 시작합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_49",
      "title": "소프트웨어 공학에서 워크스루(Walkthrough)에 대한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "인스펙션(Inspection)과 동일한 의미를 가진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "워크스루는 비공식적인 리뷰이며, 인스펙션은 공식적인 리뷰로 서로 다른 개념입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_50",
      "title": "소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "복호화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "형상관리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "저작권",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "크랙",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "소프트웨어 변경사항 관리는 형상관리(Configuration Management)에 해당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_51",
      "title": "테스트 케이스와 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "테스트 케이스는 테스트의 목표 및 방법이 결정된 후에 작성해야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_52",
      "title": "객체지향 개념을 활용한 소프트웨어 구현과 관련한 설명 중 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "private는 '비공개' 접근 제어자입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_53",
      "title": "DRM과 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "디지털 콘텐츠와 디바이스의 사용을 제한하기 위한 접근 제어 기술이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "디지털 미디어의 사용 권한 관리, 과금, 유통 단계를 관리하는 기술이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "클리어링 하우스는 콘텐츠 라이센스를 발급하고 권한을 부여하는 시스템이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통 방지는 불가능하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "DRM은 전자적 보안을 통해 불법 유통과 복제를 방지합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_54",
      "title": "위험 모니터링의 의미로 옳은 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "위험을 이해하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "첫 번째 조치로 위험을 피하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "위험 발생 후 즉시 조치하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "위험 요소 징후들을 계속적으로 인지하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "위험 요소의 징후를 지속적으로 감시하는 활동이 위험 모니터링입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_55",
      "title": "동시 수정 방지와 소프트웨어 버전 관리 도구는?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "RCS(Revision Control System)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "RTS(Reliable Transfer Service)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "RPC(Remote Procedure Call)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "RVS(Relative Version System)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "소프트웨어 버전 관리 도구는 RCS입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_56",
      "title": "화이트박스 테스트 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "논리흐름도를 이용해 이해할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "테스트 데이터를 실제 프로그램에 실행하여 오류를 찾는 동적 테스트이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "구조를 고려하지 않고 명세를 기초로 테스트한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "테스트 데이터 선택을 위한 검증기준을 정한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "화이트박스 테스트는 프로그램의 내부 구조를 기반으로 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_57",
      "title": "알고리즘 설명 중 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "컴퓨터 명령어를 순서대로 나열한 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "검색은 데이터에서 키값을 찾는 알고리즘이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "정렬은 데이터를 키값으로 순서대로 열거하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "선형 검색은 반드시 정렬된 데이터 집합에서만 수행할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "선형 검색은 데이터가 정렬되지 않아도 가능합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_58",
      "title": "겉으로 보이는 동작 변화 없이 내부구조를 변경하는 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Refactoring",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Architecting",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Specification",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Renewal",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "내부 구조 변경을 Refactoring이라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_59",
      "title": "단위 테스트와 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "각 모듈 개발 후 개발자가 명세대로 구현되었는지 테스트한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "모듈 내부 구조를 보는 구조적 테스트를 시행한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터를 인자로 넘기고 결과를 받는 모듈을 테스트 스텁이라고 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "테스트할 모듈을 호출하거나 호출당하는 모듈이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "결과를 받는 모듈은 테스트 드라이버입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_60",
      "title": "IDE 도구의 기능 중 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Coding • 프로그래밍 환경 제공",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Compile • 저급언어를 고급언어로 변환",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Debugging • 버그를 찾아 수정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Deployment • 최종 사용자에게 소프트웨어 전달",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "컴파일은 고급언어를 저급언어로 변환합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_61",
      "title": "속성•값 쌍으로 이루어진 데이터를 전달하기 위한 개방형 표준 포맷은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "JSON",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "HTML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "AVPN",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "DOF",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "속성•값 쌍을 표현하는 개방형 표준 포맷은 JSON입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_62",
      "title": "LIFO 특징을 가지는 자료구조는?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Tree",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Graph",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Stack",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Queue",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "후입선출(LIFO) 방식의 자료구조는 Stack입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_63",
      "title": "단위 테스트 도구로 사용할 수 없는 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "CppUnit",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "JUnit",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "HttpUnit",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "IgpUnit",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "IgpUnit은 단위 테스트 도구로 사용되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_64",
      "title": "소프트웨어 개발 방법론 중 프로토타입(Prototype) 방법의 장점으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "사용자의 요구사항을 조기에 파악할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "개발 과정 중 사용자와 의사소통이 원활하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "최종 결과물과 같은 수준의 완성도를 초기에 확보할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자의 요구변경을 비교적 쉽게 수용할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "프로토타입은 초기 완성도보다는 요구사항 확인이 목적입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_65",
      "title": "소프트웨어 품질 관리 지표로 적절하지 않은 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "결함 밀도(Defect Density)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "코드 복잡도(Cyclomatic Complexity)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어 비용 추정(Software Cost Estimation)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "평균 장애 간격시간(MTBF)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "소프트웨어 비용 추정은 품질 관리 지표가 아니라 비용 산정 지표입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_66",
      "title": "애자일 방법론의 특징으로 옳지 않은 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "고객과의 지속적인 협력 강조",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "계획 중심의 철저한 문서화 작업",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "짧고 반복적인 개발 주기",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "개발 과정에서 발생하는 변화에 유연한 대응",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "애자일은 철저한 문서화보다는 변화 대응을 강조합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_67",
      "title": "다음 중 소프트웨어의 유지보수 유형에 해당하지 않는 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "수정 유지보수(Corrective Maintenance)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "적응 유지보수(Adaptive Maintenance)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "예측 유지보수(Predictive Maintenance)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "완전 유지보수(Perfective Maintenance)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "예측 유지보수는 하드웨어 유지보수에 사용되는 개념입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_68",
      "title": "테스트 오라클(Test Oracle)의 설명으로 가장 적절한 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "테스트 수행 시 입력값을 생성하는 도구입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "테스트 케이스의 실행 여부를 결정하는 기준입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어 결함을 자동으로 수정하는 프로그램입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "소프트웨어 변경 사항을 기록하는 시스템입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "테스트 오라클은 테스트 케이스의 결과를 판단하는 기준입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_69",
      "title": "회귀 테스트(Regression Test)의 목적으로 옳은 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "새로 추가된 기능이 기존 기능에 영향을 미쳤는지 확인",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사용자 요구사항의 적합성 검증",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어의 성능과 안정성 평가",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "초기 개발 단계의 설계 오류 검출",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "회귀 테스트는 추가된 변경 사항이 기존 기능에 미친 영향을 확인합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_70",
      "title": "다음 중 블랙박스 테스트 기법에 해당하지 않는 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "경계값 분석(Boundary Value Analysis)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "동등 분할(Equivalence Partitioning)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "오류 예측(Fault Forecasting)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "조건 커버리지(Condition Coverage)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "조건 커버리지는 화이트박스 테스트 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_71",
      "title": "다음 중 디자인 패턴의 목적이 아닌 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "재사용성을 높이는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "코드 유지보수를 쉽게 하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "문제 해결의 속도를 향상하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "개발 도구의 성능을 최적화하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "디자인 패턴은 개발 도구 성능과는 무관합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_72",
      "title": "소프트웨어 위험 관리 절차로 가장 먼저 수행해야 하는 단계는?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "위험 모니터링",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "위험 식별",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "위험 대응 계획 수립",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "위험 분석 및 평가",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "위험 관리는 위험 식별이 가장 먼저 이루어져야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_73",
      "title": "다음 중 소프트웨어 형상 관리의 목적이 아닌 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "변경 사항 추적 및 관리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "소프트웨어 품질 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "프로젝트 비용 절감",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "소프트웨어 버전 관리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "형상 관리의 목적은 변경사항 관리이며, 비용 절감이 주요 목적은 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_74",
      "title": "클린 코드(Clean Code)를 작성하기 위한 원칙으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "의존성 : 다른 모듈에 미치는 영향을 최소화하도록 작성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "가독성 : 누구든지 읽기 쉽게 코드를 작성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "중복성 : 중복을 최소화 할 수 있는 코드를 작성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "추상화는 상세 내용을 하위 클래스에서 구현하고, 일반적인 개념을 상위 클래스에 정의합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_75",
      "title": "단위 테스트에서 하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "테스트 스텁(Test Stub)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "테스트 드라이버(Test Driver)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "테스트 슈트(Test Suites)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "테스트 케이스(Test Case)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "테스트 드라이버는 상위 모듈 역할을 수행하여 하위 모듈을 호출합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_76",
      "title": "소프트웨어 모듈화의 장점이 아닌 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "오류의 파급 효과를 최소화한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기능의 분리가 가능하여 인터페이스가 복잡하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "모듈의 재사용 가능으로 개발과 유지보수가 용이하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "프로그램의 효율적인 관리가 가능하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "모듈화는 인터페이스를 단순화하여 관리 효율성을 높입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_77",
      "title": "소프트웨어 프로젝트 관리에 대한 설명으로 가장 옳은 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "개발에 따른 산출물 관리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "소요 인력은 최대화하되 정책 결정은 신속하게 처리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "주어진 기간은 연장하되 최소의 비용으로 시스템을 개발",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "프로젝트 관리의 목적은 주어진 자원 내에서 사용자를 만족시키는 시스템 개발입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_78",
      "title": "정형 기술 검토(FTR)의 지침으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "의제를 제한한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "논쟁과 반박을 제한한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "문제 영역을 명확히 표현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "참가자의 수를 제한하지 않는다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "정형 기술 검토는 참가자 수를 적절히 제한하여 효과를 극대화합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_79",
      "title": "소프트웨어 재공학 활동 중 새로운 환경에서 사용할 수 있게 변환하는 작업은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Analysis",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Migration",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Restructuring",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Reverse Engineering",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Migration은 기존 시스템을 새로운 환경으로 이전하는 작업입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_80",
      "title": "프로그래밍 언어 선택 시 고려 사항으로 거리가 먼 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "개발 정보시스템의 특성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사용자의 요구사항",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "컴파일러의 가용성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "컴파일러의 독창성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "프로그래밍 언어 선택 시 컴파일러의 독창성은 고려 대상이 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_81",
      "title": "소프트웨어 패키징 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "패키징은 개발자 중심으로 진행한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "신규 및 변경 개발 소스를 식별하여 모듈화해 패키징 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "패키징은 사용자 중심으로 진행되어야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_82",
      "title": "자료 구조 중 선형 구조가 아닌 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "트리",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "리스트",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "스택",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데크",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "트리는 비선형 자료구조에 속합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_83",
      "title": "오래되어 유지보수가 어려운 프로그램을 의미하는 용어는?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Title Code",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Source Code",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Object Code",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Alien Code",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "Alien Code는 유지보수하기 어려운 오래된 코드를 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_84",
      "title": "소프트웨어 재사용의 이점으로 가장 거리가 먼 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "생산성 증가",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트 문서 공유",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어 품질 향상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "새로운 개발 방법론 도입 용이",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "소프트웨어 재사용은 새로운 방법론 도입과는 직접적 관련이 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_85",
      "title": "인터페이스 간 통신에 이용되지 않는 데이터 포맷은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "AJTML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "JSON",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "XML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "YAML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "AJTML은 존재하지 않는 데이터 포맷입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_86",
      "title": "NS Chart에 대한 설명으로 가장 거리가 먼 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "이해하기 쉽고 코드 변환이 용이하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "화살표나 GOTO를 사용하여 이해하기 쉽다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "연속, 선택, 반복 등의 제어 논리 구조를 표현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "NS Chart는 화살표나 GOTO 문을 사용하지 않는 구조적 표현 방식입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_87",
      "title": "자료 A, B, C, D를 push, push, pop, push, push, pop, pop, pop 수행 시 출력 결과는?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "B D C A",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "A B C D",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "B A C D",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "A B D C",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "스택(Stack)은 후입선출(LIFO) 방식으로 작동합니다. 순서대로 진행하면:\n① push A → 스택: [A]\n② push B → 스택: [A, B]\n③ pop → 출력: B, 스택: [A]\n④ push C → 스택: [A, C]\n⑤ push D → 스택: [A, C, D]\n⑥ pop → 출력: D, 스택: [A, C]\n⑦ pop → 출력: C, 스택: [A]\n⑧ pop → 출력: A, 스택: []\n따라서 최종 출력 순서는 B D C A가 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_88",
      "title": "코드 인스펙션과 관련한 설명으로 틀린 것은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "프로그램을 수행시키지 않고 눈으로 확인한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "코드 품질 향상 기법 중 하나이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "동적 테스트 시에만 활용하는 기법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "코딩 표준 준수 여부와 효율성 등을 검사한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "코드 인스펙션은 정적 테스트 기법으로 동적 테스트가 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_89",
      "title": "프로젝트의 위험 요소를 예측하고 관리하는 활동은?",
      "subject": "소프트웨어 개발",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Critical Path Method",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Risk Analysis",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Work Breakdown Structure",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Waterfall Model",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "위험 관리 활동은 Risk Analysis입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_90",
      "title": "데이터 모델에 표시해야 할 요소로 거리가 먼 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "논리적 데이터 구조",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "출력 구조",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "연산",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "제약 조건",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "데이터 모델에는 데이터 구조, 연산, 제약 조건의 3가지 요소가 표시되어야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_91",
      "title": "데이터베이스 설계 단계 중 응답 시간, 저장 공간의 효율화, 트랜잭션 처리도와 가장 밀접한 관계가 있는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "물리적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "논리적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "개념적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "요구 조건 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "물리적 데이터베이스 설계 단계에서 응답 시간, 저장 공간의 효율화 트랜잭션 처리 속도에 대한 설계를 진행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_92",
      "title": "데이터베이스 설계 단계 중 저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관계되는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "논리적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "요구 조건 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "물리적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "개념적 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "물리적 설계 단계는 논리적 설계 단계로부터 효율적인 내부 스키마를 설계하는 것입니다. 세부적으로 저장 레코드 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계가 이에 해당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_93",
      "title": "데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "저장 레코드 양식 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "레코드 집중의 분석 및 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "접근 경로 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "목표 DBMS에 맞는 스키마 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 진행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_94",
      "title": "데이터베이스 설계 단계 중 물리적 설계에 해당하는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "데이터 모형화와 사용자 뷰들을 통합한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "트랜잭션의 인터페이스를 설계한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "파일 조직 방법과 저장 방법 그리고 파일 접근 방법 등을 선정한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자들의 요구 사항을 입력으로 하여 응용 프로그램의 골격인 스키마를 작성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "물리적 설계 단계에서는 저장 레코드의 양식 설계, 레코드 집중의 분석 설계, 접근 경로 설계, 목표 DBMS에 맞는 물리적 구조 설계, 트랜잭션 세부 설계 등을 진행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_95",
      "title": "데이터베이스 설계에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "요구 조건 분석 단계는 사용자의 요구 조건을 수집하고 분석하여 사용자가 의도하는 데이터베이스의 용도를 파악해야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "개념적 설계 단계에서는 트랜잭션 인터페이스 설계, 스키마의 평가 및 정제 등의 작업을 수행한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "논리적 설계 단계에서는 개념적 설계 단계에서 만들어진 정보 구조로부터 특정 목표 DBMS가 처리할 수 있는 스키마를 생성한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "물리적 설계 단계에서는 저장 구조와 접근 경로 등을 결정한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "논리적 설계 단계에서 트랜잭션 인터페이스 설계를 진행하고 개념적 설계에서는 DBMS에 독립적인 개념 스키마 설계, 트랜잭션 모델링을 진행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_96",
      "title": "데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "산출물로 ER•D가 만들어진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "DBMS에 독립적인 개념 스키마를 설계한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "트랜잭션 인터페이스를 설계한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "논리적 설계 단계의 앞 단계에서 수행한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "트랜잭션 인터페이스 설계는 논리적 설계 단계에서 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_97",
      "title": "데이터베이스의 설계의 논리적 설계 단계에서 수행하는 작업이 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "논리적 데이터 모델로 변환",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "트랜잭션 인터페이스 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "스키마의 평가 및 정제",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "트랜잭션 모델링",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "트랜잭션 모델링은 개념적 설계 단계에서 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_98",
      "title": "데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "레코드 집중의 분석 및 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "논리적 데이터베이스 구조로 매핑(mapping)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "트랜잭션 인터페이스 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "스키마의 평가 및 정제",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "레코드 집중의 분석 및 설계는 물리적 설계 단계에서 진행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_99",
      "title": "다음 중 관계의 종류에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "종속 관계 : 식별 관계는 하위 객체에 존재하는 상위 객체가 일반 식별자에 속하는 경우이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "배타 관계 : 배타 AND 관계와 배타 OR 관계가 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "중복 관계 : 특정의 두 개체들 간에 두 번 이상의 종속 관계가 발생하는 관계이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "재귀 관계 : 데이터의 종속 관계에 있어서 특정 개체가 자기자신 개체를 다시 참조하는 관계이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "종속 관계 중 식별 관계는 하위 개체에 존재하는 상위 개체의주 식별자인 외래 식별자가 하위 개체의 주 식별자의 전체 또는 일부로 존재하는 관계입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_100",
      "title": "데이터 모델링을 수행할 때 도출되어 표현되는 관계의 종류가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "1:1 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "1:0 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "다:다 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "1:다 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "다:다 관계는 불특정 관계로 해소되어야 할 관계입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_101",
      "title": "관계 대수에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "원하는 릴레이션을 정의하는 방법을 제공하며, 비절차적 언어이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "일반 집합 연산과 순수 관계 연산으로 구분된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "관계 대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는 것인가를 기술하는 절차적인 언어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_102",
      "title": "다음 관계 대수 중 순수 관계 연산자가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "차집합(difference)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트(project)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "조인(join)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "디비전(division)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• 순수 관계 연산자 : 셀렉트, 프로젝트, 조인, 디비전 \\n• 일반 집합 연산자 : 합집합, 교집합, 차집합, 카티션 곱",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_103",
      "title": "조건을 만족하는 릴레이션의 수평적 부분 집합으로 구성하며, 연산자의 기호는 그리스 문자 시그마(σ)를 사용하는 관계 대수 연산은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "셀렉트(select)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트(project)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "조인(join)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "디비전(division)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "셀렉트(σ)는 시그마라고 읽으며, 조건을 만족하는 릴레이션의 수평적 부분 집합을 구성합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_104",
      "title": "관계 대수에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "릴레이션을 처리하기 위한 연산의 집합으로, 피연산자가 릴레이션이고 결과도 릴레이션이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 특징을 가지고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "일반 집합 연산과 순수 관계 연산이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "수학의 Predicate Calculus에 기반을 두고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "Predicate Calculus는 술어 논리로 수학에서 사용하는 어떤 지식이나 사실을 표현하는 방법으로, 관계 해석에 대한 설명입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_105",
      "title": "관계 대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "⨝",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "⊃",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "π",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "σ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "조인(⨝)은 두 릴레이션이 공통으로 가지고 있는 속성을 이용해 두 개의 릴레이션을 하나로 합쳐 새로운 릴레이션을 만드는 연산을 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_106",
      "title": "관계 대수의 순수 관계 연산자가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Select",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Cartesuab Product",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Division",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Project",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "카티션 곱은 일반 집합 연산자입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_107",
      "title": "관계 대수에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "주어진 릴레이션 조작을 위한 연산의 집합이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "일반 집합 연산과 순수 관계 연산으로 구분된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차저 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "• 관계 대수는 절차적인 방법의 언어이고, 관계 해석이 비절차적인 언어입니다.\\n• 관계 대수와 관계 해석의 차이\\n• **관계 대수**\\n1. 목적 : 절차(어떻게, How 관점)\\n2. 방법 : 집합과 관계\\n3. 접근 : 절차적\\n• **관계 해석**\\n1. 목적 : 무엇을(what)\\n2. 방법 : 서술어 해석(Predicate calculus)\\n3. 접근 : 비절차적\\n**관계 대수와 관계 해석의 공통점** : 데이터베이스 처리 기능과 능력은 동일.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_108",
      "title": "A1, A2, A3 3개 속성을 갖는 한 릴레이션에서 A1의 도메인은 3개 값, A2의 도메인은 2개 값, A3 도메인은 4개 값을 갖는다. 이 릴레이션에 존재할 수 있는 가능한 튜플(Tuple)의 최대 수는?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "24",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "12",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "8",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "9",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "속성이 갖는 도메인의 값을 모두 곱하면 전체 튜플의 최대 수를 구할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_109",
      "title": "다음 중 관계 대수의 일반 집합 연산자에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "합집합 : R U S로 표현할 수 있으며 릴레이션 R과 릴레이션 S의 한 쪽에 속한 튜플을 반환한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "교집합 : 릴레이션 R에 속하면서 릴레이션 S에 속한 튜플들의 집합이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "차집합 : 릴레이션 R에는 속하지만 릴레이션 S에는 속하지 않는 튜플의 집합이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "디비전 : 릴레이션 R에서 다른 릴레이션 S의 애트리뷰트를 제외한 나머지 애트리뷰트만 조회한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "디비전은 관계 대수 중 순수 관계 연산자입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_110",
      "title": "관계 대수의 일반 집합 연산자에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "∩, R ∩ S : 릴레이션 R에 속하면서 릴레이션 S에 동시에 속한 튜플의 집합",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "−, R − S : 릴레이션 R에는 속하지만 릴레이션 S에는 속하지 않는 튜플의 집합",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "×, R × S : 릴레이션 R의 모든 튜플을 다른 릴레이션 S의 모든 튜플과 결합",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "∪, R ∪ S : 릴레이션 R과 릴레이션 S 중에 동시에 속한 튜플의 집합",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "∪, R ∪ S는 합집합으로 릴레이션 한 쪽에만 속하거나 모두에 속한 튜플입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_111",
      "title": "다음 중 관꼐 대수의 순수 관계 연산자에 대한 연산자와 표현 방법이 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "셀렉트 • σ조건 술어(R)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트 • π속성 리스트(R)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "디비전 • R × S",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "조인 • R ⨝ S",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "디비전은 R ÷ S로 표기하고, R × S는 일반 집합 연산자인 카티션 곱의 표현 방법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_112",
      "title": "관계 해석에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "수학의 프레디킷 해석에 기반을 두고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "관계 데이터 모델의 제안자인 코드(Codd)가 관계 데이터베이스에 적용할 수 있도록 설계하여 제안하였다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "튜플 관계 해석과 도메인 관계 해석이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 특성을 가진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "관계 해석은 원하는 정보가 무엇인가를 선언하는 비절차적 언어적 특성을 갖습니다. 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 특성을 갖는 관계 대수입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_113",
      "title": "관계 해석에서 'for all : 모든 것에 대하여'의 의미를 나타내는 논리 기호는?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "∃",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "∈",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "∀",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "∪",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "전칭 정량자(for all)에 대한 설명이며, All의 A를 뒤집어 놓은 형태입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_114",
      "title": "관계 해석(relational calculus)에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "관계 해석으로 질의어로 표현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "원하는 릴레이션을 정의하는 방법을 제공하며, 비절차적인 언어이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "튜플 관계 해석과 도메인 관계 해석이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "릴레이션 조작을 위한 연산의 집합이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "릴레이션 조작을 위한 연산의 집합은 관계 대수에 대한 설명입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_115",
      "title": "관계 대수 및 관계 해석에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "관계 해석은 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 특성을 지닌다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "관계 해석과 관계 대수는 관계 데이터베이스를 처리하는 기능과 능력 면에서 동등하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "관계 해석은 원래 수학의 프레디킷 해석에 기반을 두고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "관계 대수는 릴레이션을 처리하기 위한 연산의 집합으로 피연산자가 릴레이션이고 결과도 릴레이션이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "1번은 관계 해석이 아닌 관계 대수에 대한 설명입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_116",
      "title": "관계 해석 연산자의 논리 기호와 그에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "∨ : OR 연산으로, 원자식 간 '또는'이라는 관계로 설명된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "∧ : AND 연산으로, 원자식 간의 '그리고'라는 관계로 설명된다. ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "∀ : 'A'를 뒤집어 놓은 형태로, 모든 형태의 튜플(for all)을 의미한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "¬ : 원자식에 대한 부정을 의미한다. ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "∀은 연산자가 아니고 정량자입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_117",
      "title": "관계 해석에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "원하는 정보가 무엇인지를 선언하는 절차적 특성을 갖는 관계 데이터 표현 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "관계 해석은 튜플 관계 해석과 도메인 관계 해석으로 구성된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "튜플 관계 해석은 원하는 릴레이션을 튜플 해석식으로 정의하는 표기법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "도메인 관계 해석은 사용자가 원하는 도메인 해석식으로 표현하는 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "관계 해석은 비절차적인 특성을 가지고 있는 관계 데이터 표현 방법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_118",
      "title": "다음 중 관계 해석에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "예상",
      "date": "",
      "choice1": {
        "text": "원하는 정보가 무엇이라는 것을 선언하는 비절차적인 특성을 갖는다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "수학의 서술어 해석에 기반을 가진 관계 데이터의 연산 표현 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "튜플 관계 해석은 도메인 변수와 원자식으로 표현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "논리 기호와 정량자를 이용햐 정형식을 표현할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "튜플 관계 해석은 튜플 변수와 한정 애트리뷰트, 원자식으로 표현입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_119",
      "title": "참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "CLUSTER",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "CASCADE",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "SET•NULL",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "RESTRICTED",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "문제에 제시된 내용은 CASCADE에 대한 설명입니다. \\n• RESTRICTED : 다른 개체가 제거할 용소를 참조중일 때는 제거를 취소함.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_120",
      "title": "뷰(View)에 대한 설명으로 옳지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "뷰는 CREATE 문을 사용하여 정의한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "뷰는 데이터의 논리적 독립성을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "뷰를 제거할 때에는 DROP 문을 사용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "뷰는 저장장치 내에 물리적으로 존재한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "뷰(View)는 저장장치 내에 물리적으로 존재하지 않는 가상 테이블입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_121",
      "title": "DML에 해당하는 SQL 명령으로만 나열된 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "DELETE, UPDATE, CREATE, ALTER",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "INSERT, DELETE, UPDATE, DROP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "SELECT, INSERT, DELETE, UPDATE",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "SELECT, INSERT, DELETE, ALTER",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "DML(데이터 조작어)의 4가지 명령어는 SELECT, INSERT, DELETE, UPDATE입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_122",
      "title": "관계대수의 순수 관계 연산자가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Select",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Cartesian Product",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Division",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Project",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "순수 관계 연산자에는 Select, Project, Join, Division이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_123",
      "title": "관계 데이터 모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null) 값이 아닌 원자 값을 갖는 성질은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "개체 무결성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "참조 무결성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "도메인 무결성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "튜플의 유일성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "관계 데이터 모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null) 값이 아닌 원자 값을 갖는 성질을 개체 무결성(Entity Integrity)이라고 합니다.\\n• **참조 무결성(Referential Integrity)** : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 하고, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정\\n• **도메인 무결성(Domain Integrity, 영역 무결성)** : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_124",
      "title": "제 3정규형에서 보이스코드 정규형(BCNF)으로 정규화하기 위한 작업은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "원자 값이 아닌 도메인을 분해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "부분 함수 종속 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "이행 함수 종속 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "결정자가 후보키가 아닌 함수 종속 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "BCNF는 결정자가 모두 후보키인 정규형으로, 제3정규형에서 결정자가 후보키가 아닌 것을 제거하면 BCNF가 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_125",
      "title": "로킹(Locking) 기법에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "로킹 단위가 작아지면 병행성 수준이 낮아진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터베이스도 로킹 단위가 될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "로킹 단위가 커지면 로크 수가 작아 로킹 오버헤드가 감소한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "로킹 단위가 작아지면 병행성 수준이 높아집니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_126",
      "title": "데이터베이스 전체를 정의한 것으로 데이터개체, 관계, 제약조건, 접근권한, 무결성 규칙 등을 명세한 것을 의미하는 스키마(Schema)는?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "개념 스키마",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "내부 스키마",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "외부 스키마",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "내용 스키마",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "문제의 지문은 개념 스키마에 대한 설명입니다.\\n• **외부 스키마** : 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것\\n• **내부 스키마** : 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_127",
      "title": "시스템 카탈로그에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지관리한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "카탈로그에 저장된 정보를 메타 데이터라고도 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "시스템 카탈로그는 일반 이용자도 SQL을 통해 검색할 수는 있지만, 갱신은 허용되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_128",
      "title": "병행제어 기법의 종류가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "로킹 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사분할 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "타임스탬프 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "다중 버전 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "병행제어 기법의 종류에는 로킹, 타임 스탬프 순서, 최적 병행 수행, 다중 버전 기법이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_129",
      "title": "데이터 속성 간의 종속성에 대한 엄밀한 고려 없이 잘못 설계된 데이터베이스에서는 데이터 처리 연산 수행 시 각종 이상 현상이 발생할 수 있는데, 이러한 이상 현상이 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "검색 이상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "삽입 이상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "삭제 이상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "갱신 이상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "이상(Anomaly)의 종류에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_130",
      "title": "트랜잭션의 주요 특성 중 하나로, 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Log",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Consistency",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Isolation",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Durability",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "문제에 제시된 내용은 독립성(Isolation)에 대한 설명입니다.\\n• **Consistency(일관성)** : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함\\n• **Durability(영속성, 지속성)** : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_131",
      "title": "물리적 데이터베이스 설계에 대한 설명으로 거리가 먼 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "트랜잭션의 인터페이스를 설계하고 데이터 타입 및 타입들 간의 관계 표현은 논리 데이터베이스 설계에서 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_132",
      "title": "데이터베이스에 영햐을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "CASE 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "일치 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "CRUD 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "연관성 분석",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것을 CRUD 분석이라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_133",
      "title": "데이터베이스에는 관계형, 계층형, 네트워크형 등 다양한 종류가 있는데 이들을 구분하는 기준은?",
      "subject": "데이터베이스 구축",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "개체(Object)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "관계(Relationship)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "속성(Attribute)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "제약 조건(Constraint)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "관계형, 계층형, 네트워크형 데이터베이스를 구분하는 기준은 관계(Relationship)입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_134",
      "title": "트랜잭션의 특성 중 원자성(Atomicity)에 대한 설명으로 옳은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "트랜잭션은 부분적으로 실행될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "트랜잭션은 실행 도중 중단될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "모든 작업이 완료되거나 전혀 수행되지 않아야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "데이터베이스는 항상 일관된 상태를 유지한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "정답은 '모든 작업이 완료되거나 전혀 수행되지 않아야 한다.'입니다. 원자성은 트랜잭션의 모든 작업이 완료되거나 전혀 실행되지 않아야 함을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_135",
      "title": "관계형 데이터베이스의 기본 구성 요소가 아닌 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "테이블",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "속성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "인스턴스",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "트리거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "트리거는 데이터베이스 객체이지만 기본 구성 요소는 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_136",
      "title": "정규화의 목적 중 가장 거리가 먼 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "중복 데이터 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "데이터 일관성 유지",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "성능 최적화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "삽입 이상 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "정규화는 성능 최적화보다는 데이터 구조의 일관성과 이상 현상 제거에 중점을 둡니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_137",
      "title": "데이터베이스의 무결성 제약 조건 중 도메인 제약에 해당하지 않는 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "열의 데이터 형식",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "값의 범위",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "참조 무결성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "허용되는 값 목록",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "참조 무결성은 외래 키 제약 조건으로 도메인 제약 조건이 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_138",
      "title": "뷰(View)의 특징으로 적절하지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "논리적 데이터 독립성 제공",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "물리적 공간 차지",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "보안 기능 제공",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "가상 테이블",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "정답은 '물리적 공간 차지'입니다. 뷰는 실제 데이터를 저장하지 않으므로 '물리적 공간 차지'이라는 선택지는 적절하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_139",
      "title": "데이터베이스의 이상(Anomaly) 중 삭제 이상이 발생하는 경우는?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "중복된 데이터가 삽입되는 경우",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "하나의 데이터를 삭제하면서 다른 유용한 데이터도 함께 삭제되는 경우",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터 갱신이 여러 곳에서 발생하는 경우",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "정규화로 인해 조인이 복잡해지는 경우",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "삭제 이상은 데이터를 삭제할 때, 함께 삭제되지 말아야 할 정보까지 사라지는 문제를 말합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_140",
      "title": "데이터베이스의 외래 키(Foreign Key)에 대한 설명으로 틀린 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "외래 키는 다른 테이블의 기본 키를 참조한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "외래 키는 NULL 값을 가질 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "외래 키는 참조 무결성을 유지하는 데 사용된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "외래 키는 두 테이블 간의 관계를 정의한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "외래 키는 NULL 값을 가질 수 있으며, 반드시 NOT NULL 제약 조건이 적용되는 것은 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_141",
      "title": "E•R 모델에서 엔티티와 엔티티 사이의 관계를 나타내는 요소는?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "속성(Attribute)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "릴레이션(Relation)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "관계(Relationship)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "스키마(Schema)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "E•R 모델에서는 엔티티 간의 관계를 '관계(Relationship)'로 표현합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_142",
      "title": "데이터베이스에서 기본 키(Primary Key)의 특징으로 적절하지 않은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "중복될 수 없다",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "NULL 값을 가질 수 있다",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "튜플을 유일하게 식별한다",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "한 테이블에 하나만 존재할 수 있다",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "기본 키는 절대 NULL 값을 가질 수 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_143",
      "title": "제3정규형(3NF)의 정의로 적절한 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "모든 속성이 기본 키에 이행적으로 종속되지 않는 정규형",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "모든 속성이 기본 키에 함수적으로 종속되지 않는 정규형",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "중복을 최소화한 정규형",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "후보 키에만 종속되어 있는 정규형",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "제3정규형은 이행적 함수 종속을 제거하여 기본 키에만 직접적으로 종속되도록 만드는 정규형입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_144",
      "title": "SQL에서 SELECT 문의 실행 순서 중 가장 먼저 수행되는 절은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "SELECT",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "FROM",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "WHERE",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "ORDER BY",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "SELECT 문의 실행 순서는 FROM → WHERE → SELECT → ORDER BY 순으로 처리됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_145",
      "title": "데이터베이스에서 트랜잭션의 고립성(Isolation) 보장을 위해 사용하는 기법은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "데이터 정규화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "동시성 제어",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "스키마 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "뷰 생성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "동시성 제어는 트랜잭션 간의 고립성을 유지하기 위해 사용되는 대표적인 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_146",
      "title": "ER 모델에서 하나의 엔티티가 자기 자신과 관계를 맺는 것을 무엇이라 하는가?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "자기 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "재귀 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "이진 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "다대다 관계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "자기 자신과 관계를 맺는 경우는 재귀 관계(Recursive Relationship)라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_147",
      "title": "다음 중 트랜잭션의 일관성(Consistency)에 해당하는 설명은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "트랜잭션은 부분적으로 실행될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "트랜잭션 수행 전과 수행 후의 데이터베이스는 항상 일관된 상태여야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "트랜잭션은 병행적으로 실행될 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "트랜잭션은 항상 자동으로 커밋된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "일관성은 트랜잭션 전후의 데이터베이스가 규칙을 만족하는 일관된 상태여야 함을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_148",
      "title": "관계형 데이터베이스에서 후보 키(Candidate Key)의 정의로 옳은 것은?",
      "subject": "데이터베이스 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "기본 키로 선정될 수 있는 속성들의 집합",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "중복 값을 허용하는 키",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "데이터 무결성을 위한 외래 키",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "두 개 이상의 테이블을 연결하는 키",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "후보 키는 튜플을 유일하게 식별할 수 있는 속성들의 집합으로, 기본 키로 선정될 수 있는 자격을 가집니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_149",
      "title": "C언어에서 문자열 처리 함수의 서식과 그 기능의 연결로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "strlen(s) • S의 길이를 구한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "strcpy(s1, s2) • s2를 s1으로 복사한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "strcmp(s1, s2) • s1과 s2를 연결한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "strrev(s) • s를 거꾸로 변환한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "stcmp는 s1과 s2에 저장된 문자열이 동일한지 비교하는 함수입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_150",
      "title": "IPv6에 대한 설명으로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "128비트의 주소 공간을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "인증 및 보안 기능을 포함하고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "패킷 크기가 64Kbyte로 고정되어 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "IPv6의 패킷 크기는 제한이 없습니다. 패킷 크기가 64Kbyte로 고정되어 있는 것은 IPv4입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_151",
      "title": "파이썬의 변수 작성 규칙 설명으로 옳지 않은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "첫 자리에 숫자를 사용할 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "영문 대문자/소문자, 숫자, 밑줄(_)의 사용이 가능하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "변수 이름의 중간에 공백을 사용할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "이미 사용되고 있는 예약어는 사용할 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "변수 이름의 중간에 공백을 넣을 수 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_152",
      "title": "스레드(Thread)에 대한 설명으로 옳지 않은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "한 개의 프로세스는 여러 개의 스레드를 가질 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_153",
      "title": "C언어에서 산술 연산자가 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "%",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "*",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "/",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "=",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "• =는 대입 연산자입니다.\\n• C언어의 산술 연산자에는 +, •, *, /, %가 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_154",
      "title": "C Class에 속하는 IP address는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "200.168.30.1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "10.3.2.1 4",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "225.2.4.1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "172.16.98.3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "C Class에 속하는 IP address의 범위는 192.0.0.0 ~ 223.255.255.255까지입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_155",
      "title": "빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB일 때 기억장치 배치 전략으로 \"Best Fit\"을 사용하여 17KB의 프로그램을 적재할 경우 내부 단편화의 크기는 얼마인가?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "3KB",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "23KB",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "64KB",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "67KB",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "최적 적합(Best•Fit)은 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 적게 남기는 분할 영역에 배치시키는 방법으로, 17KB보다 큰 기억공간 중 가장 작은 기억공간인 20KB에 배치됩니다. 이 때 발생하는 내부 단편화는 3KB(20KB•17KB)입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_156",
      "title": "UNIX에서 새로운 프로세스를 생성하는 명령어는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "ls",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "cat",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "fork",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "chmod",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "UNIX에서 새로운 프로세스를 생성하는 명령어는 fork입니다.\\n• cat : 파일 내용을 화면에 표시함.\\n• chmod : 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정함\\n• ls : 현재 디렉터리 내의 파일 목록을 확인함",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_157",
      "title": "페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "기억장소 이용 효율이 증가한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "입•출력 시간이 늘어난다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "내부 단편화가 감소한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "페이지 맵 테이블의 크기가 감소한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "페이지 크기가 작아질수록 페이지의 개수가 많아져 주소를 저장하는 맵 테이블의 크기가 커지게 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_158",
      "title": "C언어에서 두 개의 논리 값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "||",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "&&",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "**",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "!=",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "||(논리 or)는 하나라도 참이면 참을 반환하는 연산자입니다. 영어로는 'or'을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_159",
      "title": "IPv6의 주소체계로 거리가 먼 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Unicast",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Anycast",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Broadcast",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Multicast",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "IPv6의 주소 체계로는 유니캐스트(Unicast), 멀티캐스트(Multicast), 애니케스트(Anycast)가 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_160",
      "title": "어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Data Coupling",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Stamp Coupling",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Control Coupling",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Common Coupling",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "문제에 제시된 내용은 Control Coupling(제어 결합도)에 대한 설명입니다,",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_161",
      "title": "TCP/IP에서 사용되는 논리 주소를 물리 주소로 변환시켜 주는 프로토콜은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "TCP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "ARP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "FTP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "IP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "TCP/IP 네트워크에서 논리 주소를 물리 주소로 변환하는 프로토콜은 ASP(Address Resolution Protocol)입니다.\\n• TCP(Transmission Control Protocol) : 신뢰성 있는 연결형 서비스를 제공하고, 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공함\\n• FTP(File Transfer Protocol) : 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜\\n• IP(Internet Protocol) : 데이터그램을 기반으로 하는 비연결형 서비스와 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_162",
      "title": "운영체제의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Locality",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Deadlock",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Thrashing",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Working Set",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합을 워킹 셋(Working Set)이라고 합니다.\\n• Locality(국부성, 지역성, 구역성, 국소성) : 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론\\n• Dead Lock(교착상태) : 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상\\n• Thrasing : 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_163",
      "title": "개발에 필요한 환경 구축과 관련하여 하드웨어 환경과 관련이 없는 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Eclipse",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Oracle DB",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "WAS",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "웹 서버",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "이클립스(Eclipse)는 통합 개발 환경(IDE) 도구로, 하드웨어 환경과 관련이 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_164",
      "title": "UNIX에 대한 설명으로 옳지 않은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "상당 부분 C 언어를 사용하여 작성되었으며, 이식성이 우수하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어 여러 개의 작업을 병행 처리할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "쉘(Shell)은 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "쉘(Shell)은 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기입니다. 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행하는 것은 커널(Kernel)입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_165",
      "title": "C 또는 Java의 Print 명령어에서 키보드의 [Tab] 키와 같이 커서를 일정 간격 띄어주는데 사용하는 제어문자는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "\\r",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "\\t",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "\\b",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "\\\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "\\r : 커서를 현재 줄의 처음으로 이동하는 제어문자 \\n\\b : 커서를 왼쪽으로 한 칸 이동하는 제어문자\\n\\\\n : 커서를 다음 줄의 처음으로 이동하는 제어문자",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_166",
      "title": "한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생하며, 권리 전도 현상이 발생할 수 있다. 이 내용이 설명하는 결합도는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "제어 결합도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "스탬프 결합도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "외부 결합도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "내용 결합도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "문제의 지문은 제어 결합도에 대한 설명입니다.\\n• **스탬프 결합도** : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 떄의 결합도\\n• **외부 결합도** : 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도\\n• **내용 결합도** : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_167",
      "title": "OSI 참조 모델의 계층별 프로토콜 데이터 단위(PDU)의 연결이 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Physical Layer • Byte",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Data Link Layer • Frame",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Network Layer • Packet",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Application Layer • Message",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "물리 계층(Physical Layer)의 프로토콜 데이터 단위(PDU)는 비트(bit)입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_168",
      "title": "JAVA에서 힙(Heap)에 남아있으니 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "Heap Collector",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Garbage Collector",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Memory Collector",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Variable Collector",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "실제로는 사용되지 않으면서 가용 공간 리스트에 반환되지 않는 메모리 공간인 가비기(Garbage, 쓰레기)를 강제로 해제하여 사용할 수 있도록 하는 메모리 관리 모듈을 가비지 콜렉터(Garbage Collecter)라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_169",
      "title": "다음 중 연산자의 종류가 다른 하나는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "%",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "/",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "•",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "++",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "①, ②, ③번은 산술 연산자, ④번은 단항 연산자입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_170",
      "title": "운영체제의 기능으로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "개발에 필요한 여러 도구를 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "자원 보호 기능을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "자원의 스케줄링 기능을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자와 시스템 간의 편리한 인터페이스를 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "개발에 필요한 여러 도구를 제공하는 소프트웨어에는 라이브러리, 프레임워크, API, IDE 등이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_171",
      "title": "IEEE 802.3 LAN에서 사용되는 전송 매체 접속 제어(MAC) 방식은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "CSMA/CD",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Token Bus",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Token Ring",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Slotted Ring",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "IEEE 802.3의 매체 접근 방식은 CSMA/CD 방식입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_172",
      "title": "주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법으로, 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행하는 할당 기법은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "오버레이",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "스와핑",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "페이징",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "세그먼테이션",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "문제의 설명에 해당하는 할당 기법은 오버레이(Overlay) 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_173",
      "title": "배치 프로그램의 자동 수행 주기 중 사용자가 특정 조건을 설정해두고 해당 조건이 충족될 때만 수행하도록 하는 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "정기 배치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "이벤트성 배치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "On•Demand 배치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자 배치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "배치 프로그램의 자동 수행 주기 중 특정 조건을 설정해 두고 해당 조건이 충족될 때만 수행되는 것을 이벤트성 배치라고 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_174",
      "title": "다음 중 Java에서 표준 출력 시 사용하는 명령어가 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "prn",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "print",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "printf",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "printIn",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Java에서 표준 출력에 사용되는 메소드에는 print, printf, printIn이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_175",
      "title": "스크립트(Script) 언어가 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "PHP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Fortran",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Basic",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Python",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Fortran은 과학 기술 계산용 언어로 절차적 프로그래밍 언어에 속합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_176",
      "title": "다음 중 페이지 교체(Page Replacement) 알고리즘이 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "LRU",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "OPT",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "NUR",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "SCF",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "페이지 교체 알고리즘의 종류에는 OPT, FIFO, LRU, LFU, NUR, SCR 등이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_177",
      "title": "네트워크 계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행하는 네트워크 장비는 무엇인가?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "리피터(Repeater)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "브리지(Bridge)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "라우터(Router)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "게이트웨이(Gateway)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행하는 장비는 게이트웨이(Gateway)입니다.\\n• **리피터(Repeater)** : 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 용니으로 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행함.\\n• **브리지(Bridge)** : LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행함.\\n **라우터(Router)** : 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행함",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_178",
      "title": "Java에서 자료형과 크기의 연결로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "byte •  1Byte",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "char •  1Byte",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "int •  4Byte",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "double •  8Byte",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "char는 C언어에서는 1Byte이지만, Java에서는 2Byte의 크기를 갖습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_179",
      "title": "스크립트 언어가 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "PHP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Cobol",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Basic",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Python",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Cobol은 절차적 프로그래밍 언어에 해당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_180",
      "title": "OSI 7계층 중 네트워크 계층에 대한 설명으로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "패킷에 발신지와 목적지의 논리 주소를 추가한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "• ②번은 데이터 링크 계층의 특징입니다.\\n• 네트워크 계층의 프로토콜 데이터 단위(PDU)는 패킷(Packet)입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_181",
      "title": "C, Java 언어 등에서 사용되는 예약어로, 반복문 안에서 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮기는 명령어는 무엇인가?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "break",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "continue",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "next",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "release",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "• 반복문에서 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮기는 명령어(예약어)는 continue 입니다.\\n• break는 반복문의 처음이 아닌 반복문을 벗어나는 명령어이며, next와 release는 존재하지 않는 명령어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_182",
      "title": "3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "1, 2, 0",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "2, 4, 3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "1, 4, 2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "4, 1, 3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "3개의 페이지를 수용할 수 있는 주기억장치이므로 아래 그림과 같이 3개의 페이지 프레임으로 표현할 수 있습니다.\\n(이미지)\\n※ ⦁ : 페이지 부재 발생\\n참조 페이지가 페이지 테이블에 없을 경우 페이지 결함(부재)이 발생됩니다. 초기에는 모든 페이지가 비어 있으므로 처음 1, 2, 0 페이지 적재 시 페이지 결함이 발생됩니다. FIFI(선입선출) 기법은 가장 먼저 들어와 있었던 페이지를 교체하는 깁버이므로 참조 페이지 4를 참조할 때에는 1을 제거한 후 4를 가져오게 됩니다. 이러한 과정으로 모든 페이지에 대한 요구를 처리하고 나면 총 페이지 결함 발생 횟수는 6회이고 마지막 프레임의 최종 상태는 4, 1, 3입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_183",
      "title": "서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 마이크로소프트 사에서 제작하였으며, Windows 계열에서만 수행 가능한 프로그래밍 언어는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "자바스크립트(JAVA Script)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "ASP(Active Server Page)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "JSP(Java Server Page)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "파이썬(Python)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "문제의 지문에 제시된 내용은 ASP(Active Server Page)의 특징입니다.\\n• **자바스크립트(JAVA Script)** : 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어로, 클래스 기반의 객체 상속을 지원하여 객체지향 프로그래밍 언어의 성격도 갖고 있음.\\n• **JSP(Java Server Page)** : JAVA로 만들어진 서버용 스크립트로, 다양한 운영체제에서 사용이 가능함\\n• **파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프리터 언어로, 객체지향 기능을 지원하고 플랫폼에 독립적이며 문법이 간단하여 배우기 쉬움",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_184",
      "title": "다음 중 IP 버전에 대한 설명 중 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "IPv4는 각 부분을 옥텟으로 구성, 총 32비트로 구성된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "IPv6는 각 부분을 콜론으로 구분한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "IPv4는 네트워크 부분의 길이에 따라 A클래스에서 E클래스까지 총 5단계로 구성되어 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "IPv6는 IPv4에 비해 자료 전송 속도가 느리다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "IPv6는 IPv4에 비해 자료 전송 속도가 빠릅니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_185",
      "title": "서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능하며 C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용되는 스크립트 언어는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "PHP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Basic",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "C#",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Python",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "문제에 제시된 내용은 PHP(Professional Hypertext Preprocessor)에 대한 설명입니다.\\n• **BASIC** : 교육용 언어이며, 초보자를 위한 간단한 대화형(Interpreter) 언어임.\\n• **C#** : .Net 프레임워크의 한 부분으로 만들어진 C언어로, C++과 Visual Basic의 편의성을 결합함.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_186",
      "title": "다음 중 Myers가 구분한 응집도(Cohesion)의 정도에서 가장 낮은 응집도를 갖는 단계는?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "순차적 응집도(Sequential Cohesion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기능적 응집도(Functional Cohesion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "시간적 응집도(Temporal Cohesion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "우연적 응집도(Coincidental Cohesion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "응집도를 강한 것에서 약한 것 순으로 나열하면 '기능적 응집도 → 순차적 응집도 → 교환(통신)적 응집도 → 절차적 응집도 → 시간적 응집도 → 우연적 응집도'입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_187",
      "title": "교착 상태 발생의 필요 충분 조건이 아닌 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "상호 배제(Mutual Exclusion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "점유와 대기(Hold and Wait)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "환형 대기(Circular Wait)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "선점(Preemption)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "교착 상태 발생의 필요 충분 조건 4가지는 상호 배제, 점유와 대기, 환형 대기, 비전섬입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_188",
      "title": "다음 중 비선점(Non• Preemptive) 스케줄링에 해당하지 않는 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "SJF",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "HRN",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "FCFS",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "SRT",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "SRT는 선점(Preemptive) 스케줄링 기법에 해당합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_189",
      "title": "C언어에서 사용할 수 없는 변수명은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "student2025",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "text• color",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "_korea",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "amount",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "변수명에는 공백이나 *,+,• ,/ 등의 특수문자를 사용할 수 없습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_190",
      "title": "라이브러리의 개념과 구성에 대한 설명 중 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "프로그래밍 언어가 기본적으로 가지고 있는 라이브러리가 표준 라이브러리, 별도의 파일 설치를 필요로 하는 라이브러리는 외부 라이브러리입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_191",
      "title": "C언어 라이브러리 중 stdlilb.h에 대한 설명으로 옳은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "기출",
      "date": "2024",
      "choice1": {
        "text": "문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "문자열 처리 함수로 strlen()이 포함되어 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "표준 입출력 라이브러리이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "②번은 string.h, ③번은 stdio.h, ④번은 marth.h에 대한 설명입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_192",
      "title": "보기 중 C언어에서 포인터에 대한 설명으로 틀린 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "포인터는 메모리 주소를 저장하는 변수이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "포인터 변수 앞에 *를 붙이면 해당 주소의 값을 참조한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "NULL 포인터는 항상 1의 값을 가진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "포인터는 배열과 유사하게 사용될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "NULL 포인터는 0의 값을 가지며, 메모리를 참조하지 않는 상태를 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_193",
      "title": "Python에서 리스트(list)에 대한 설명으로 옳지 않은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "리스트는 순서가 있는 컬렉션이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "리스트는 변경이 가능한(mutable) 객체이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "리스트는 중복 값을 허용하지 않는다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "리스트는 다양한 데이터 타입을 함께 저장할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "리스트는 중복 값을 허용합니다. 같은 값을 여러 번 포함할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_194",
      "title": "다음 보기 중 Java에서 클래스(class)에 대한 설명으로 옳은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "클래스는 객체의 인스턴스를 말한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "클래스는 메서드를 가질 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "클래스는 사용자 정의 자료형이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "클래스는 하나의 객체만 생성할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "클래스는 사용자 정의 자료형(User Defined Type)으로 객체 생성을 위한 설계도입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_195",
      "title": "아래 중 스레드(Thread)의 장점으로 가장 적절한 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "스레드는 메모리를 독립적으로 사용한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "스레드를 사용하면 프로그램의 처리율이 향상될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "스레드는 운영체제에서만 동작한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "스레드는 반드시 사용자에 의해 생성되어야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "스레드를 사용하면 여러 작업을 동시에 처리할 수 있어 처리율을 향상시킬 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_196",
      "title": "C언어에서 switch 문에 대한 설명으로 옳지 않은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "switch 문은 조건에 따라 분기 처리를 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "case 레이블은 정수형 상수여야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "default 문은 반드시 있어야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "break 문은 각 case 종료 시 사용된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "default 문은 선택사항이며, 작성하지 않아도 문법 오류가 발생하지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_197",
      "title": "보기 중 Java에서 클래스(class)에 대한 설명으로 옳은 것은?",
      "subject": "프로그래밍 언어 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "클래스는 객체의 인스턴스를 말한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "클래스는 메서드를 가질 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "클래스는 사용자 정의 자료형이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "클래스는 하나의 객체만 생성할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "클래스는 사용자 정의 자료형(User Defined Type)으로 객체 생성을 위한 설계도입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_198",
      "title": "소프트웨어 개발에서 정보보안 3요소에 해당하지 않는 설명은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "기밀성 : 인가된 사용자만 자원 접근 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "무결성 : 인가된 사용자만 자원 수정 가능하며 전송중 정보 수정 안됨",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "가용성 : 인가된 사용자는 언제든 자원 접근 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "휘발성 : 데이터 처리 후 즉시 폐기",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "정보보안 3요소는 기밀성, 무결성, 가용성입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 2
    },
    {
      "id": "ques_199",
      "title": "접속 인가 여부를 점검해 접근 제어하는 유틸리티는?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "tcp wrapper",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "trace checker",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "token finder",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "change detector",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "tcp wrapper는 네트워크 접근제어 도구입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_200",
      "title": "10cm 이내 근접 초고속 데이터 전송 NFC 기술은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "BcN",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Zing",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Marine Navi",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "C•V2X",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Zing은 초고속 근접무선통신 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_201",
      "title": "취약점 관리 위한 보안 설정과 거리가 먼 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "서버 관리실 출입 통제",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "실행 프로세스 권한 설정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "운영체제의 접근 제한",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "운영체제의 정보 수집 제한",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "서버 관리실 출입 통제는 물리적 보안입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_202",
      "title": "소프트웨어 개발 프레임워크 설명 중 적절하지 않은 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "반제품을 사용한 재사용성 확대 소프트웨어",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사용자 코드가 프레임워크를 호출하고 제어함",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "소프트웨어 디자인 패턴을 반제품 상태로 집적화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "제어 흐름이 IoC 원리를 따름",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "프레임워크가 사용자 코드를 호출하고 제어합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_203",
      "title": "클라우드 기반 HSM 설명 중 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "클라우드 기반 키 생성 및 저장 보안기기",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "전자서명법 개정과 관련하여 용어 등장",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "클라우드에 인증서 저장하여 휴대폰 저장 불필요",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "소프트웨어적 구현이라 보안 취약점 존재",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "클라우드 HSM은 하드웨어 기반 보안 장치입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_204",
      "title": "물리적 위협이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "천재지변 위협",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "하드웨어 파손",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "물리적 파괴 행위",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "방화벽 설정 오류",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "방화벽 설정 오류는 논리적 위협입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_205",
      "title": "스스로 전파하며 증식하는 악성코드는?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "Worm",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Rogue Ware",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Adware",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Reflection Attack",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "웜(Worm)은 자가 전파 및 복제 악성코드입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_206",
      "title": "애자일 방법론 특징과 거리가 먼 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "단계별 완전 확인 후 진행",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "구성원 간 의사소통 중시",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "즉각적 환경 변화 대응",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "상황에 따른 주기적 조정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "애자일은 빠른 반복과 유연한 진행이 특징입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_207",
      "title": "대칭 암호 알고리즘 설명 중 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "다양한 암호 핵심 함수로 사용 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "키 교환 없이 암호화 및 복호화 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "비밀키 사용한 인증 및 전자서명 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "AES, IDEA 등이 대표적",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "대칭 암호는 비밀키 전달(키 교환)이 필요합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_208",
      "title": "두 명의 개발자가 5개월에 10000 라인의 코드 개발 시 월별 생산성 계산은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "10000／2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "10000／(5×2)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "10000／5",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "(2×10000)／5",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "월별 생산성은 전체 코드 수를 총 투입 인원수와 개월 수를 곱한 값으로 나눈 것입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_209",
      "title": "조직 내 개인의 역할에 따라 접근 권한을 부여하는 방법은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "RBAC",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "DAC",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "MAC",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "QAC",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "RBAC(Role•Based Access Control)는 직무 기반 접근 제어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_210",
      "title": "COCOMO 모형의 특징이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "man•month로 산정 결과를 나타낼 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "원시코드 라인 수에 의한 비용 산정 기법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "중소 규모 프로젝트 비용 추정에 적합하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "object, dynamic, function의 3가지 모드로 구분한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "COCOMO 모형은 organic, semi•detached, embedded 모드로 구분됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_211",
      "title": "사용자 인증 유형 설명 중 적절하지 않은 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "지식 : 알고 있는 것(패스워드, PIN)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "소유 : 가지고 있는 것(토큰, 스마트카드)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "존재 : 대체하는 것(패턴, QR)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "행위 : 하는 것(서명, 움직임, 음성)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "존재 인증은 신체적 특징(지문, 홍채 등) 기반이며, 패턴, QR은 존재 인증이 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_212",
      "title": "프로젝트 일정 관리 시 사용하는 PERT 차트 설명은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "2022",
      "choice1": {
        "text": "막대 도표를 이용하여 일정 표시",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "시간선(Time•line) 차트라고도 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "수평 막대 길이는 작업 기간을 나타낸다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "작업 간 관련성, 결정경로, 자원할당을 제시한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "PERT 차트는 작업 간의 관계와 자원 할당 및 임계 경로를 나타냅니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_213",
      "title": "소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은??",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템이 완성된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "나선형 모델은 반복적으로 개발하며 각 반복 주기에서 위험 분석을 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_214",
      "title": "위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Parsing",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "LAN Tapping",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Switch Jamming",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "FTP Flooding",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "Switch Jamming은 스위치의 MAC 테이블을 가득 채워 정상 동작을 방해하는 공격입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_215",
      "title": "취약점 관리를 위해 일반적으로 수행하는 작업이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "무결성 검사",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "응용 프로그램의 보안 설정 및 패치(Patch) 적용",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "중단 프로세스 및 닫힌 포트 위주로 확인",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "불필요한 서비스 및 악성 프로그램의 확인과 제거",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "취약점 관리는 실행 중인 프로세스와 열린 포트를 중심으로 수행해야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_216",
      "title": "소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "V 모델은 요구 분석, 설계 단계를 거치며 각 단계에 맞는 테스트가 대응됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_217",
      "title": "블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "블루버그(BlueBug) • 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "블루스나프(BlueSnarf) • 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "블루프린팅(BluePrinting) • 블루투스 공격 장치의 검색 활동을 의미",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "블루재킹(BlueJacking) • 블루투스 장비 사이의 취약한 연결 관리를 악용한 공격",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "블루프린팅은 블루투스 장치를 검색해 정보를 수집하는 수단입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_218",
      "title": "DoS(Denial of Service) 공격과 관련한 내용으로 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Smurf 공격은 브로드캐스트를 이용한 공격입니다. 멀티캐스트가 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_219",
      "title": "간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "자원 배치 계획에 유용하게 사용된다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "CPM 네트워크로부터 만드는 것이 가능하다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "수평 막대는 인원수가 아닌 각 작업의 소요 시간을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_220",
      "title": "Python 기반의 웹 크롤링(Web Crawling) 프레임워크로 옳은 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Li•fi",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Scrapy",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "CrawlCat",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "SBAS",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "Scrapy는 Python 기반 웹 크롤링 프레임워크로 많이 사용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_221",
      "title": "Secure 코딩에서 입력 데이터의 보안 약점과 관련한 설명으로 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "SQL 삽입 : 사용자의 입력 값 등 외부 입력 값이 SQL 쿼리에 삽입되어 공격",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "크로스사이트 스크립트 : 검증되지 않은 외부 입력 값에 의해 브라우저에서 악의적인 코드가 실행",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "운영체제 명령어 삽입 : 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "자원 삽입은 보안 약점이 아니라 자원 관리 문제입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_222",
      "title": "Windows 파일 시스템인 FAT와 비교했을 때의 NTFS의 특징이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "보안에 취약",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "대용량 볼륨에 효율적",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "자동 압축 및 안정성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "저용량 볼륨에서의 속도 저하",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "NTFS는 FAT보다 보안이 강화된 파일 시스템입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_223",
      "title": "DES는 몇 비트의 암호화 알고리즘인가?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "8",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "24",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "64",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "132",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "DES는 64비트 블록 크기를 가지며, 56비트의 키를 사용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_224",
      "title": "리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "22",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "666",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "777",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "755",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "기본 권한 666에서 644가 되려면 umask는 022입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_225",
      "title": "상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "낙관치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기대치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "비관치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "모형치",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "LOC 기법에서는 낙관치, 비관치, 기대치를 사용하며 '모형치'는 사용되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_226",
      "title": "OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "PLCP(Packet Level Control Processor)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "Traffic Distributor",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "Packet Tree",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "DPI(Deep Packet Inspection)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "DPI는 Deep Packet Inspection의 약자로 패킷 내용을 분석하는 보안 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_227",
      "title": "소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "테일러링은 변화에 유연하게 대응하며 프로젝트 특성에 맞추는 것이 핵심입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_228",
      "title": "정보시스템 개발 시 요구사항 분석 단계에서 수행하는 활동으로 가장 적절한 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "테스트 케이스 작성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "UI 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자의 기대 기능 및 조건을 수집하고 문서화",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "서버 구축 및 설정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "요구사항 분석 단계에서는 사용자의 요구를 명확히 파악하고 이를 문서화합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_229",
      "title": "정보시스템 아키텍처 구성 요소로 볼 수 없는 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "업무 아키텍처",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "데이터 아키텍처",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "보안 아키텍처",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "물리 보안 장비 설계",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "물리 보안 장비 설계는 정보시스템 아키텍처의 직접적인 구성 요소가 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_230",
      "title": "정보시스템의 성능 평가 기준으로 적절하지 않은 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "처리량(Throughput)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "응답 시간(Response Time)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "정확도(Accuracy)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "휴먼 인터페이스 감성 디자인",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "감성 디자인은 정성적 요소로 성능 평가의 핵심 기준은 아닙니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_231",
      "title": "정보시스템 개발 시 표준화가 필요한 가장 주된 이유는?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "디자인의 다양성 확보",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "문서의 양을 줄이기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "서로 다른 시스템 간 상호 운용성과 일관성 확보",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자 요구사항을 쉽게 변경하기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "표준화는 시스템 간 상호운용성과 품질 유지를 위한 중요한 요소입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_232",
      "title": "정보시스템 구축 시 산출물에 해당하지 않는 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "요구사항 명세서",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "소스코드",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "테스트 결과 보고서",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "사용자 개인의 메모",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 4,
      "explanation": {
        "text": "개인의 메모는 공식적인 개발 산출물로 인정되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_233",
      "title": "정보시스템의 변경 요청(Change Request)에 대한 설명으로 옳지 않은 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "기능 추가를 포함할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "프로젝트 완료 후에는 처리할 수 없다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자의 요구에 의해 발생할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "변경 요청은 형상관리 절차에 따라 문서화되어야 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "변경 요청은 유지보수 기간에도 계속해서 발생하고 처리될 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_234",
      "title": "정보시스템의 생명주기 관점에서 유지보수 단계에서 수행되지 않는 작업은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "시스템 성능 개선",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "기능 추가",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "사용자 교육",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "오류 수정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "사용자 교육은 일반적으로 개발 완료 직후 운영 준비 단계에서 수행됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_235",
      "title": "정보시스템 개발의 타당성 분석에서 고려할 사항이 아닌 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "기술적 타당성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "운영 환경의 정치적 흐름",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "경제적 타당성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "법적 타당성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "정치적 흐름은 통상적인 타당성 분석 기준에 포함되지 않습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_236",
      "title": "정보시스템의 품질 속성 중 '사용자가 쉽게 배울 수 있는 정도'를 의미하는 것은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "신뢰성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "사용성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "이식성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "성능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 2,
      "explanation": {
        "text": "사용성은 시스템이 얼마나 쉽게 사용될 수 있는지를 나타내는 품질 요소입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_237",
      "title": "정보시스템 구축 시 프로젝트 범위 관리의 목적은?",
      "subject": "정보 시스템 구축 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "예산을 줄이기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "일정을 단축하기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "필요한 작업과 산출물을 명확히 정의하고 통제하기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "성과급을 높이기 위해",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 3,
      "explanation": {
        "text": "프로젝트 범위 관리는 작업 내용과 산출물을 명확히 하고 변경을 통제하는 데 목적이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_238",
      "title": "STUDENT 테이블에서 컴퓨터과 학생 50명, 인터넷과 학생 100명, 사무자동화과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과에 따른 튜플의 수는? (단, DEPT 칼럼은 학과명이다.)",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 200\n\n2. 3\n\n3. 1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "SQL 문1은 STUDENT 테이블 전체에서 중복 제거 없이 튜플을 세므로 학과별 인원(50+100+50)=200명이 반환됩니다.\nSQL 문2는 DISTINCT DEPT로 학과 종류(컴퓨터과, 인터넷과, 사무자동화과) 3개를 반환합니다.\nSQL 문3은 WHERE DEPT='컴퓨터과' 조건과 COUNT(*) 없이 학과명만 요청하므로 컴퓨터과 학생 50명에서 중복 제거를 하지 않아 1개의 튜플만 반환됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_239",
      "title": "웹 애플리케이션에서 클라이언트가 입력한 검색 키워드를 그대로 SQL 문에 삽입하여 실행할 때 발생할 수 있는 대표적 보안 취약점은 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "SQL Injection",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "사용자 입력이 SQL 구문으로 해석되어 의도치 않은 데이터 조회·조작이 일어나는 'SQL Injection'이 대표적입니다. PreparedStatement 등의 파라미터 바인딩 기법으로 방어할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_240",
      "title": "릴레이션을 제3정규형까지 정규화하면 대부분 해결되는 이상(Anomaly) 3가지를 쓰시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "삽입 이상, 삭제 이상, 갱신 이상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "정규화를 하지 않으면 데이터 중복으로 인해 삽입 이상, 삭제 이상, 갱신 이상이 발생합니다. 이를 방지하기 위해 제3정규형 이상으로 정규화를 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_241",
      "title": "다음이 설명하는 제품 패키지 릴리스 노트의 작성 항목은 무엇인가?",
      "subject": "제품소프트웨어 패키징",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "해더\n\n \n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "릴리스 노트에는 제품 패키지의 버전, 변경 사항, 설치/배포 방법 등을 포함해야 합니다.\n특히 릴리스 노트 상단의 **헤더(Header)** 영역에는 제품명, 버전, 릴리스 날짜, 작성자 등의 기본 정보가 기재됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_242",
      "title": "다음은 C언어 소스 코드이다. 출력 결과를 쓰시오. \n",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "50758595100",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": " #include <stdio.h>\n void main(){\n \tint i,j;\n    int temp;\n    int a[5] = {75,95,85,100,50};\n    \n    for(i=0; i<4; i++){\n    \tfor(j=0; j<4-i; j++){\n        \tif(a[j] > a[j+1]){\n            \ttemp=a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n             }\n           }\n        }\n        \n       \tfor(i=0; i<5; i++){\n        \tprintf(\"%d\", a[i]);\n        }\n  }",
      "answer": 1,
      "explanation": {
        "text": "제공된 C 프로그램은 버블 정렬로 배열 {75,95,85,100,50}을 오름차순 정렬합니다.\n정렬 후 배열은 {50,75,85,95,100}이며, 공백 없이 연속해서 출력하므로 50758595100이 콘솔에 표시됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_243",
      "title": "다음은 자바 소스코드이다. 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "-8",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class good {\n\tpublic static void main(String[] args){\n    \tint i = 3;\n        int k = 1;\n        swich (i) {\n        case 0;\n        case 1;\n        case 2;\n        case 3 k = 0;\n        case 4 k += 3;\n        case 5 k -= 10;\n        default: k--;\n        }\n        system.out.print(k);\n     }\n}\n        ",
      "answer": 1,
      "explanation": {
        "text": "switch 문에서 변수 i가 3일 때 case 3부터 default까지 break가 없으므로 모두 순차 실행됩니다.\n초기 k=1 → case 3에서 k=0 → case 4에서 k+=3 → k=3 → case 5에서 k-=10 → k=-7 → default에서 k-- → k=-8.\n따라서 최종 출력은 -8입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_244",
      "title": "다음은 자바 소스코드이다. 출력 결과를 쓰시오",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "0 1 2 3\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class good {\n\tpublic static void main(String[] args){\n    \tint i;\n        int[] a = {0,1,2,3};\n        for(i=0; i<4; i++){\n        \tSystem.out.print(a[i] + \" \");\n        }\n     }\n }",
      "answer": 1,
      "explanation": {
        "text": "Java 프로그램은 배열 a = {0,1,2,3}을 선언하고 for문으로 각 요소를 순서대로 출력합니다.\n따라서 화면에는 0 1 2 3 \"(마지막에 공백) 이 출력됩니다.\"",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_245",
      "title": "다음은 버블 정렬(Bubble Sort)을 구현하는 C 코드이다. PASS 1(1회전) 후 배열 a의 상태를 순서대로 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "4 5 2 7 9",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int a[5]={7,4,5,2,9};\nfor(int i=0;i<4;i++){\n  for(int j=0;j<4-i;j++){\n    if(a[j]>a[j+1]){\n      int t=a[j]; a[j]=a[j+1]; a[j+1]=t;\n    }\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "버블 정렬은 인접한 원소를 비교하고 교환하여 정렬합니다. 1회전 후 가장 큰 값인 9가 배열의 맨 끝으로 이동하여 배열은 4 5 2 7 9가 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_246",
      "title": "다음은 공통 모듈 구현의 개념에 대한 설명이다. 괄호 (    ) 안에 알맞은 용어를 쓰시오.",
      "subject": "통합 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 결합도\n\n2. 응집도\n\n ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "공통 모듈 구현에서는 결합도를 낮추고 응집도를 높이는 것이 핵심입니다.\n결합도(Coupling)는 모듈 간 의존성을 의미하며, 결합도가 낮을수록 유지보수성이 향상됩니다.\n응집도(Cohesion)는 한 모듈 내부 요소들의 관련성으로, 응집도가 높을수록 모듈이 하나의 책임에 집중하게 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_247",
      "title": "RFC 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로 인지를 확인하는 무결성 검사 등에 사용된다. 1991년 로널드 라이베스트가 예전에 쓰이던 MD4를 대체하기 위해 고안된 128비트 암호화 해시 함수는 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "MD5",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "MD5는 무결성 검사를 위한 해시 함수이며, 128비트 해시값을 생성하여 파일 변조 여부를 확인할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_248",
      "title": "OSI 계층 중 비트를 전송하는 계층은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "물리 계층",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "OSI 7계층 중 물리 계층은 실제 비트가 전송되는 계층으로, 케이블, 전압 등 물리적 특성을 다룹니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_249",
      "title": "LoC(Line of Code)가 30,000라인이고, 개발자가 5명이며, 개발자가 월평균 300라인을 개발한다. 이때 프로젝트 개발 기간과 계산식을 쓰시오.",
      "subject": "요구사항 확인",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "20개월, 30000 / (5 * 300)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "LoC 30,000줄을 1인당 월 300줄 작성하면, 5명 기준 총 개발 기간은 20개월입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_250",
      "title": "프로토콜의 기본 요소 3가지를 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "구문(Syntax), 의미(Semantics), 타이밍(Timing)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "프로토콜은 통신 규약이며, 구문은 데이터 형식, 의미는 동작 정의, 타이밍은 송수신 속도 및 순서를 뜻합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_251",
      "title": "트랜잭션의 특징 중, 일관성 지속성 외 2개의 특성을 쓰시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "원자성, 격리성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "트랜잭션의 특성은 ACID로 요약되며, 원자성은 모두 실행되거나 실행되지 않아야 함을, 격리성은 트랜잭션이 독립적으로 수행됨을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_252",
      "title": "스케줄링 방식에서 HRN(Highest Response ratio Next) 우선순위 계산식을 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "(대기시간 + 서비스시간) / 서비스시간",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "HRN 방식은 대기 시간이 길고 서비스 시간이 짧을수록 우선순위가 높아지는 방식으로, 응답률을 기반으로 계산합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_253",
      "title": "속성-값(Attribute-value Pair)으로 이루어진 데이터 오프젝트를 전달하기 위해 사용하는 개방형 표준 포멧이다. Ajax(Asynchronous JavaScript and XML)에서 많이 사용되고 XML(eXtensible Markup Language)을 대체하는 주요 데이터 포맷이다. 언어 독립형 데이터 포맷으로 다양한 데이터 프로그래밍 언어에서 사용하고 있는 기술은 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "JSON",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "JSON은 키-값 쌍으로 구성된 데이터 형식으로 Ajax 통신 등에 많이 활용되며 XML을 대체하는 경량 데이터 포맷입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_254",
      "title": "살충제 패러독스의 개념에 관해서 서술하시오",
      "subject": "애플리케이션테스트 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "동일한 테스트 케이스를 반복 실행하면 결함 탐지가 어려워지는 현상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "살충제 패러독스는 동일한 테스트 케이스를 반복적으로 사용할 경우 결함을 더 이상 발견하지 못하게 되는 현상으로, 테스트 케이스의 다양성과 갱신이 필요함을 강조합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_255",
      "title": "사용자에게 읽기/쓰기/실행 권한을 부여하고, 그룹에게는 읽기/실행 권한을 부여하며, 그 외에는 실행 권한만을 a.txt에 부여하는 명령어를 8진법으로 한 줄로 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "chmod 751 a.txt",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "chmod 751은 소유자에게 rwx, 그룹에게 r-x, 기타 사용자에게 --x 권한을 부여하는 8진법 설정입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_256",
      "title": "비정규화(De-Normalization)의 개념을 쓰시오",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "정규화된 데이터를 성능 향상 목적으로 통합/중복 저장하는 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "비정규화는 조인 성능 향상과 시스템 최적화를 위해 정규화된 데이터를 역정규화하여 일부 중복을 허용하는 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_257",
      "title": "데이터 마이닝의 개념에 관해서 서술하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "대용량 데이터에서 의미 있는 패턴이나 규칙을 추출하는 과정",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "데이터 마이닝은 수많은 데이터로부터 유용한 정보를 자동으로 찾아내는 과정으로, 예측, 분류, 연관성 분석 등에 활용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_258",
      "title": "공격자가 패킷의 출발지 주소나 포트를 임의로 변경해 출발지와 목적지 주소를 동일하게 함으로써 공격 대상 컴퓨터의 실행속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격 방법은 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Land 공격",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Land 공격은 출발지 IP와 목적지 IP를 동일하게 설정하여 시스템 자원을 고갈시키는 서비스 거부 공격입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_259",
      "title": "UI 설계 원칙 4가지 중 사용자의 목적을 정확하게 달성하여야 함을 나타내는 특성은 무엇인지 쓰시오",
      "subject": "화면 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "유효성(Validity)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "UI 설계의 유효성은 사용자가 목표를 정확히 달성할 수 있는지 여부로, 실질적 만족도와 정확성을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_260",
      "title": "SQL Injection이 무엇인지 서술하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "웹 애플리케이션에서 사용자 입력값에 악의적 SQL문을 삽입하여 DB를 조작하는 공격 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "SQL Injection은 입력 필드를 통해 SQL문을 주입해 인증 우회 또는 데이터 탈취가 가능한 취약점 공격입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_261",
      "title": "Linux 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용프로그램(웹 브라우저 등) 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제로 개발자들이 자바와 코틀린 언어로 응용 프로그램을 작성할 수 있게 했고, 컴파일 된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영체제는 무언인지 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "안드로이드(Android)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "안드로이드는 리눅스 커널 기반의 모바일 운영체제로, 구글이 개발했으며 다양한 기기에서 사용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_262",
      "title": "형상 통제를 설명하시오.",
      "subject": "제품소프트웨어 패키징",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "소프트웨어 개발 산출물의 버전 관리와 변경 이력 추적",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "형상 통제는 소프트웨어 개발 산출물(소스코드, 문서 등)의 변경 및 버전을 체계적으로 관리하는 활동입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_263",
      "title": "트랜잭션 Rollback에 대해 설명하시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "트랜잭션 실행 중 오류 발생 시 이전 상태로 복구하는 작업",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Rollback은 트랜잭션 처리 중 오류가 발생했을 때 작업을 취소하고 데이터베이스를 일관된 상태로 되돌리는 기능입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_264",
      "title": "정보시스템 운영 중 서버가 다운되거나 자연재해, 시스템 장애 등의 이유로 고객에게 서비스가 불가능한 경우가 종종 발생한다. 이와 같은 상황에서 비상사태 또는 업무중단 시점부터 업무가 복구되어 정상 가동될 때까지의 시간을 의미하는 용어는 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "RTO (Recovery Time Objective)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "RTO는 장애 발생 후 시스템이 정상 운영 상태로 복구되기까지의 목표 시간을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_265",
      "title": "절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론으로, 개발 기간이 짧고 신속하며, 워터폴에 대비되는 방법론으로 최근 회사에서 각광받는 방법론은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "애자일(Agile) 방법론",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "애자일은 사용자의 요구에 유연하고 신속하게 대응하며, 반복적이고 점진적인 개발을 추구하는 경량 개발 방법론입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_266",
      "title": "전 세계 오픈된 정보를 하나로 묶는 방식으로 link data와 open data의 합성어가 무엇인지 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "LOD (Linked Open Data)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "LOD (Linked Open Data)는 전 세계에 분산된 오픈 데이터를 URI(웹 주소)로 연결하여 서로 연결된 거대한 데이터 웹(Web of Data)을 만드는 것을 의미합니다.\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_267",
      "title": "애플리케이션을 실행하지 않고, 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위해 사용하는 도구는 무엇인지 쓰시오.",
      "subject": "애플리케이션테스트 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "정적 분석 도구",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "정적 분석 도구는 프로그램을 실행하지 않고 소스코드를 분석해 오류나 스타일 위반 등을 찾아내는 도구입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_268",
      "title": "사용자에게 읽기 / 쓰기 / 실행 권한을 부여하고 그룹에게는 읽기 / 실행을 부여하고 그 이외에는 실행 권한을  a.txt에 부여하는 명령어를 한줄로 작성하시오 (8진법을 사용하시오)",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "chmod 751 a.txt",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "chmod 명령어에서 7(읽기+쓰기+실행), 5(읽기+실행), 1(실행) 권한을 각각 사용자/그룹/기타에 부여하는 8진수 설정입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_269",
      "title": "브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부분만을 위한 데이터를 로드하는 기법이며, HTML만으로 다양한 작업을 구현해 이용자가 웹 페이지와 자유롭게 상호작용할 수 있도록 하는 기술은 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "AJAX",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "AJAX는 비동기 JavaScript와 XML을 활용해 전체 페이지를 새로 고치지 않고도 부분 갱신을 가능하게 하는 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_270",
      "title": "무결성과 인증을 보장하는 인증헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용한 프로토콜로, 네트워크 계층인 IP에 보안성을 제공하는 표준 기술은 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "IPSec",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "IPSec은 AH와 ESP를 사용하여 IP 통신의 보안을 강화하는 표준 프로토콜입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_271",
      "title": "대표적인 내부 라우팅 프로토콜로 다익스트라 알고리즘을 이용한 대규모 네트워크에 적합한 링크 상태 라우팅 프로토콜로 불리는 라우팅 프로토콜은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "OSPF",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "OSPF(Open Shortest Path First)는 다익스트라 알고리즘을 이용해 최단 경로를 계산하는 링크 상태 라우팅 프로토콜로, 대규모 네트워크에 적합합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_272",
      "title": "UI 설계 원칙 중 직관성에 대해서 쓰시오.",
      "subject": "화면 설계",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "직관적이어야 한다",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "직관성은 사용자가 별도의 학습 없이도 UI를 자연스럽게 이해하고 사용할 수 있어야 함을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_273",
      "title": "TCP/IP에서 오류가 발생하면 (      ) 메세지를 보내서 오류가 발생했음을 알린다. 괄호 (     )안에 들어갈 용어를 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ICMP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "TCP/IP 프로토콜 스택에서 오류 발생 시, ICMP(Internet Control Message Protocol)를 이용해 오류를 알립니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_274",
      "title": "EAI를 구성하는 네가지 요소 중 메세지 버스(Message bus), 하이브리드(Hybrid), 포인트 투 포인트(Point-to-point)외의 남은 한가지 요소는 무엇인가?",
      "subject": "통합 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "허브 앤 스포크 (Hub & Spoke)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "EAI의 구성 방식은 Point-to-Point, Hub & Spoke, Message Bus, Hybrid로 구성되며, 남은 하나는 Hub & Spoke입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_275",
      "title": "C++에서 생성자란 무엇인지 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "객체 생성 시 자동 호출되어 초기화를 담당하는 특별한 멤버 함수",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "생성자는 클래스의 객체가 생성될 때 자동으로 호출되어, 멤버 변수의 초기값을 설정하는 역할을 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_276",
      "title": "테스트의 종류 중, 둥치분할 테스트, 경계값 분석 테스트 등의 종류가 있는 테스트 기법을 쓰시오.",
      "subject": "애플리케이션테스트 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "동등 분할 테스트",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "동등 분할 테스트는 입력 데이터를 동등한 그룹으로 나누어 대표값을 선택하여 테스트하는 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_277",
      "title": "심리학자 톰 마릴은 컴퓨터가 메세지를 전달하고, 메세지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메세지를 재전송하는 일련의 방법을 '기술적 은어'를 뜻하는 (      )이라는 용어로 정의했다. 괄호 (    ) 안에 들어갈 용어를 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ACK",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "ACK(acknowledgment)는 메시지가 성공적으로 수신되었음을 송신자에게 알리는 응답으로, 재전송 여부를 결정하는 중요한 요소입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_279",
      "title": "릴레이션 A, B가 있을 때 릴레이션 B 조건에 맞는 것들만 릴레이션 A에서 튜플을 꺼내 프로젝션하는 관계 대수의 기호는 무엇인가?",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "σ (Selection)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "관계 대수에서 조건에 맞는 튜플을 선택하는 연산은 선택(σ) 연산이며, 이를 통해 원하는 데이터를 추출할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_280",
      "title": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하는 기술은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "NAT (Network Address Translation)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "NAT는 사설 IP 주소를 공인 IP 주소로 변환하여 네트워크 통신을 가능하게 하는 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_281",
      "title": "현재 IPv4의 확장형으로 IPv4가 가지고 있는 주소 고갈, 보안성, 이동성 지원 등을 보완한 프로토콜은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "IPv6",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "IPv6는 IPv4의 주소 고갈 문제를 해결하고 보안성과 이동성을 강화한 차세대 인터넷 프로토콜입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_282",
      "title": "테스트 오라클 중 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클은?",
      "subject": "애플리케이션테스트 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "부분 오라클",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "부분 오라클은 전체 입력에 대한 결과를 제공하지 않고, 특정 입력에 대해서만 기대 결과를 명시하는 오라클입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_283",
      "title": "이상 현상의 종류 3가지를 쓰시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "과부하, 과열, 자원 고갈",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "시스템 운영 중 이상 현상으로는 과부하, 과열, 자원 고갈 등이 대표적입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_284",
      "title": "오픈 소스 기반으로 한 분산 컴퓨팅 플랫폼으로, 일반 PC급 컴퓨터들로 가상화된 대형 서버를 구성하여 대용량 데이터를 처리할 수 있도록 지원하는 기술은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "하둡 (Hadoop)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "하둡은 오픈 소스 기반의 분산 컴퓨팅 플랫폼으로, 대용량 데이터를 효율적으로 저장 및 처리할 수 있도록 지원합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_285",
      "title": "스니핑(Sniffing)에 대하여 서술하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "네트워크 트래픽을 몰래 감청하여 민감 정보를 탈취하는 공격 기법",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "스니핑은 네트워크 상의 데이터를 비인가로 감청하여 정보를 탈취하는 공격 방식입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_286",
      "title": "분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술로 P2P 방식을 기반으로 하여 소규모 데이터들이 연결된 체인 형태로 구성되어 있는 기술은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "블록체인",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "블록체인은 분산 네트워크 상에서 데이터를 블록 단위로 연결하여 위변조를 방지하는 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_287",
      "title": "목적에 따른 디자인 패턴의 유형에는 생성, 구조, (  )이/가 있다. 괄호 안에 들어갈 단어는?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "행동",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "디자인 패턴은 생성, 구조, 행동 세 가지 유형으로 분류됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_288",
      "title": "데이터베이스의 회복(Recovery) 기법 중 Rollback 시 Redo와 Undo의 차이를 설명하시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Rollback은 트랜잭션 중 오류 발생 시 수행된 작업을 모두 취소(Undo)하여 데이터베이스를 이전 상태로 복원하며, Redo는 장애 복구 시 완료된 트랜잭션을 재적용하는 기법이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Rollback은 오류 발생 시 데이터 일관성을 유지하기 위해 트랜잭션을 취소하는 과정이며, Redo는 장애 복구 시 정상적인 결과를 재적용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_289",
      "title": "데니스 리치와 켄톰슨 등이 함께 벨 연구소를 통해 만든 운영체제이며, 90% 이상이 C언어로 구현되어 이식성과 모듈화가 뛰어난 운영체제는 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "UNIX",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "UNIX는 벨 연구소에서 개발된 운영체제로, 대부분이 C언어로 구현되어 이식성과 모듈화가 뛰어납니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_290",
      "title": "UI 설계 원칙 중 사용자의 예상과 일치하는 결과가 나타나도록 설계하는 원칙은 무엇인가?",
      "subject": "화면 설계",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "일관성(Consistency)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "일관성(Consistency)은 UI 요소가 사용자의 기대에 부합하도록 일관된 동작과 표시를 제공하는 설계 원칙입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_291",
      "title": "UI 설계 시, 사용자가 가능한 한 최소한의 노력으로 원하는 결과를 얻을 수 있도록 하는 설계 원칙은 무엇인가?",
      "subject": "화면 설계",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "효율성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "UI 설계의 효율성 원칙은 사용자가 최소한의 조작 및 입력으로 쉽게 원하는 결과를 얻을 수 있도록 설계하는 것을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_292",
      "title": "RAID 기술의 주요 목적 두 가지를 서술하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "성능 향상, 데이터 신뢰성 보장(장애 대비)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "RAID는 디스크의 성능(읽기·쓰기 속도)을 향상시키고, 디스크 장애 시 데이터 손실 없이 복구가 가능하도록 데이터 신뢰성을 제공합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_293",
      "title": "Python에서 리스트(List)의 끝에 원소를 추가하는 메소드는 무엇인가?",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "append()",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "append() 메소드는 Python 리스트의 끝에 새로운 요소를 추가할 때 사용하는 메소드입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_294",
      "title": "OSI 7계층 중 데이터 링크 계층의 주요 기능 두 가지를 서술하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "오류 제어, 흐름 제어",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "데이터 링크 계층의 주요 기능은 오류 제어(오류 감지 및 복구)와 흐름 제어(송수신 간의 데이터 전송 속도 제어)를 수행하는 것입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_295",
      "title": "MVC 패턴에서 ‘Controller’의 역할은 무엇인지 1문장으로 설명하시오.",
      "subject": "통합 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "사용자의 입력을 받아 이를 모델(Model)에 전달하고, 그 결과를 뷰(View)에 반영하도록 제어하는 역할",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Controller는 사용자의 입력을 받아 Model에 전달하여 데이터를 처리하고, 그 결과를 View가 사용자에게 표시하도록 연결 및 제어하는 역할을 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_296",
      "title": "Java에서 인터페이스(interface)의 특징을 간략히 설명하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "모든 메소드는 추상 메소드이고, 다중 상속을 지원한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Java 인터페이스는 기본적으로 추상 메소드를 포함하고, 다중 구현을 지원합니다. 클래스는 여러 인터페이스를 구현하여 다중 상속을 지원합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_297",
      "title": "Java에서 오버라이딩(Overriding)과 오버로딩(Overloading)의 차이를 간단히 서술하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "오버라이딩은 상속받은 메소드를 재정의하는 것, 오버로딩은 같은 이름의 메소드를 매개변수 형태만 다르게 정의하는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "오버라이딩은 부모 클래스의 메소드를 재정의하는 것이고, 오버로딩은 매개변수가 다르면 같은 이름의 메소드를 여러 개 정의할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_298",
      "title": "Java에서 예외(Exception)를 처리하는 기본 키워드 두 가지를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "try, catch",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "try 블록은 예외 발생 가능성이 있는 코드를 감싸고, catch 블록은 예외 발생 시 실행될 코드를 정의합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_299",
      "title": "Java 프로그램이 실행되는 순서(컴파일과 실행 과정)를 올바른 순서로 나열하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "소스코드 작성 → 컴파일 → 바이트코드 생성 → JVM이 실행",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "작성된 Java 소스는 컴파일되어 바이트코드(.class 파일)로 변환되고, 이 바이트코드를 JVM이 실행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_300",
      "title": "IPv4 주소 체계에서 A 클래스의 기본 서브넷 마스크를 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "255.0.0.0",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "IPv4의 A 클래스 주소 기본 서브넷 마스크는 255.0.0.0이며, 네트워크 주소 부분을 나타냅니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_301",
      "title": "HTTP 프로토콜의 요청 메소드 중 데이터를 서버로 전송하여 새로운 리소스를 생성할 때 주로 사용하는 메소드는 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "POST",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "HTTP의 POST 메소드는 새로운 데이터를 서버에 전송해 새로운 리소스를 생성할 때 가장 많이 사용되는 요청 방식입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_302",
      "title": "HTTP 상태 코드 중 클라이언트 요청이 성공적으로 처리되었음을 나타내는 대표적인 코드는 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "200 OK",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "HTTP 200 OK는 클라이언트의 요청이 성공적으로 서버에 의해 처리되었음을 나타내는 상태 코드입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_303",
      "title": "DDL의 대표적인 명령어 3가지를 쓰시오.",
      "subject": "SQL 응용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "CREATE, ALTER, DROP",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "DDL 명령어는 데이터베이스의 구조를 정의하거나 변경합니다. 대표적으로 CREATE(생성), ALTER(변경), DROP(삭제)이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_304",
      "title": "C언어의 구조체(Struct)에 대해 간략히 설명하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "구조체는 서로 다른 타입의 변수들을 하나의 이름으로 묶어 관리하는 사용자 정의 자료형이다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "구조체는 다양한 타입의 변수들을 하나로 묶어 하나의 논리적 단위로 관리하는 사용자 정의 자료형입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_305",
      "title": "C언어에서 함수 호출 시 Call by Value와 Call by Reference의 차이를 간단히 서술하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "Call by Value는 값을 복사해 전달하고, Call by Reference는 주소를 전달하여 직접 값을 변경할 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Call by Value는 인자의 복사본을 함수에 전달해 원본은 유지되고, Call by Reference는 주소를 전달하여 함수가 원본을 직접 수정할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_306",
      "title": "C언어에서 포인터(Pointer)가 필요한 이유를 간단히 서술하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "메모리 주소를 직접 다루어 변수에 직접 접근하거나 동적 메모리 할당을 가능하게 한다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "포인터를 사용하면 메모리 주소를 통해 직접 변수에 접근하거나, 동적 메모리 할당 등 효율적인 메모리 관리를 할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_307",
      "title": "C언어에서 배열(Array)과 포인터(Pointer)의 관계를 간략히 설명하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "배열 이름은 배열의 첫 번째 요소를 가리키는 포인터로 사용될 수 있다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "배열 이름은 배열의 시작 주소를 가리키며, 포인터처럼 배열 요소에 접근하는 데 사용될 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_308",
      "title": "형상 관리에서 변경 사항을 기록하고 추적하기 위한 문서는 무엇인가?",
      "subject": "제품소프트웨어 패키징",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "변경 관리 보고서(Change Log)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "변경 관리 보고서(Change Log)는 소프트웨어에서 이루어진 모든 변경 사항을 기록하고, 변경 내역과 변경된 이유 등을 관리하기 위한 문서입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_309",
      "title": "형상 관리 도구로 널리 사용되는 Git의 버전 관리 단위는 무엇인가?",
      "subject": "제품소프트웨어 패키징",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "커밋(Commit)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Git에서는 하나의 커밋(Commit)을 통해 파일 변경 이력을 기록하며 버전 관리를 수행합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_310",
      "title": "프로세스의 상태 전이도에서 준비 상태에서 실행 상태로 전환되기 위한 조건을 서술하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "스케줄러에 의해 CPU가 할당됨",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "준비 상태(Ready)에서 실행 상태(Running)로 전환되기 위해서는 스케줄러가 해당 프로세스에 CPU를 할당해야 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_311",
      "title": "프로그래밍 언어에서 '재귀(recursion)'란 무엇인지 설명하시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "함수나 메소드가 자기 자신을 직접 또는 간접적으로 호출하는 구조",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "재귀(recursion)는 함수가 자기 자신을 호출하여 문제를 더 작은 단위로 나누어 해결하는 프로그래밍 기법으로, 팩토리얼이나 피보나치 수열 구현 등에 자주 쓰입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_312",
      "title": "클라이언트의 요청 없이 서버가 먼저 데이터를 보내는 방식의 웹 기술로, 실시간으로 데이터를 전달할 때 주로 사용되는 기술은 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "Server Push",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Server Push는 서버가 클라이언트 요청 없이 데이터를 주도적으로 클라이언트에게 실시간으로 전송하는 방식으로, WebSocket 등 다양한 기술로 구현됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_313",
      "title": "자료 구조에서 FIFO(First-In First-Out) 구조를 갖는 데이터 구조는 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "큐(Queue)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "큐는 가장 먼저 들어온 데이터가 가장 먼저 나가는 선입선출(FIFO) 방식을 따르는 자료구조입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_314",
      "title": "자료 구조에서 '이진 탐색 트리(Binary Search Tree)'의 특징을 간략히 서술하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "왼쪽 자식 노드는 부모보다 작고, 오른쪽 자식 노드는 부모보다 큰 값을 가진다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "이진 탐색 트리(Binary Search Tree)는 왼쪽 서브트리는 부모보다 작은 값, 오른쪽 서브트리는 부모보다 큰 값을 저장하는 트리입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_315",
      "title": "인터페이스 설계 원칙 중 사용자가 시스템의 상태 변화를 쉽게 이해하도록 설계하는 원칙은 무엇인가?",
      "subject": "화면 설계",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "피드백(Feedback)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "피드백(Feedback)은 시스템 상태나 결과를 사용자에게 명확히 알려 사용자가 쉽게 인지할 수 있도록 돕는 UI 설계 원칙입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_316",
      "title": "웹 페이지의 구조를 담당하는 표준 마크업 언어는 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "HTML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "HTML은 웹 페이지의 내용을 구조화하여 표현하는 표준 마크업 언어로, 웹 페이지의 뼈대를 구성합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_317",
      "title": "웹 기반의 문서 교환 표준 포맷으로, 사람과 기계가 모두 이해할 수 있는 형태로 되어있는 마크업 언어는 무엇인가?",
      "subject": "인터페이스 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "XML",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "XML은 데이터 저장과 전송을 위한 인간과 기계 모두 이해 가능한 표준 마크업 언어입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_318",
      "title": "운영체제에서 교착상태(Deadlock)의 발생 조건 4가지 중 하나를 쓰시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "상호 배제(Mutual exclusion)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "교착상태 발생 조건 중 하나인 상호 배제는 자원을 둘 이상이 동시에 사용할 수 없는 상황을 의미합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_319",
      "title": "애플리케이션 테스트 단계 중 시스템을 구성하는 모든 모듈을 통합하여 테스트하는 단계는 무엇인가?",
      "subject": "애플리케이션테스트 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "통합 테스트(Integration Test)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "통합 테스트는 개별 모듈을 결합하여 전체 시스템이 설계대로 잘 동작하는지 검증하는 테스트 단계입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_320",
      "title": "애플리케이션 개발 시 사용하는 Git 명령어 중, 원격 저장소의 최신 변경사항을 지역 저장소로 가져오되 즉시 병합하지 않고 로컬에 저장하는 명령어는 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "git fetch",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "git fetch 명령은 원격 저장소의 최신 내용을 지역 저장소에 저장하되, 즉시 병합하지 않고 변경 사항을 확인 후 나중에 병합할 수 있도록 합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_321",
      "title": "소프트웨어 테스트 방법 중 블랙박스 테스트의 대표적인 장점을 하나 쓰시오.",
      "subject": "애플리케이션테스트 관리",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "소스 코드 구조와 무관하게 테스트 가능",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "블랙박스 테스트는 내부 코드에 상관없이 입력과 출력만으로 테스트할 수 있어 사용자의 관점에서 기능을 검증할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_322",
      "title": "소프트웨어 아키텍처 스타일 중 클라이언트와 서버가 명확히 구분되어 있는 구조는 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "Client-Server 구조",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Client-Server 구조는 클라이언트가 요청하고 서버가 응답하는 방식으로, 역할이 명확히 구분되어 있어 유지보수와 확장성이 용이합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_323",
      "title": "소프트웨어 개발 보안에서 입력값 유효성 검사의 필요성을 간략히 서술하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "시스템에 유입되는 잘못된 데이터로 인한 보안 취약점 방지",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "입력값 유효성 검사는 잘못되거나 악의적인 데이터가 시스템에 들어와 발생하는 보안 취약점을 사전에 차단하기 위한 필수 보안 조치입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_324",
      "title": "소프트웨어 개발 보안 원칙 중 데이터의 무결성을 보장하기 위한 대표적인 방법을 하나 쓰시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "해시함수(Hash Function)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "해시 함수는 입력값에 대해 고정된 길이의 해시값을 생성하여 데이터 무결성을 검증하거나 저장합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_325",
      "title": "사용자가 입력을 시작하면 미리 준비한 데이터를 제공해 입력을 빠르고 정확하게 할 수 있게 하는 UI 기술은 무엇인가?",
      "subject": "화면 설계",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "자동 완성(Auto Complete)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "자동 완성(Auto Complete)은 사용자가 입력하는 동안 시스템이 예상되는 단어를 추천해 입력을 빠르게 돕는 UI 기술입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_326",
      "title": "사용자 인터페이스(UI) 설계에서, 사용자가 시스템 상태를 정확히 파악하고 예상 가능한 피드백을 제공받는 설계 원칙은 무엇인가?",
      "subject": "화면 설계",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "가시성(Visibility)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "가시성은 사용자가 시스템 상태와 작업 결과를 즉각적이고 명확히 인식하도록 정보를 제공하는 UI 설계 원칙입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_327",
      "title": "메모리 관리에서 내부 단편화(Internal Fragmentation)에 대해 설명하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "할당된 메모리 중 일부가 사용되지 않고 낭비되는 현상",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "내부 단편화란 메모리 블록이 할당될 때 요청된 크기보다 큰 블록이 할당되어 일부 공간이 낭비되는 현상을 말합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_328",
      "title": "디자인 패턴 중 객체의 생성과 사용을 분리하여 독립적으로 관리하는 패턴은 무엇인가?",
      "subject": "응용SW기초 기술 활용",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "Factory Method 패턴",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Factory Method 패턴은 객체 생성 로직을 별도로 분리해 코드의 재사용성과 확장성을 높이는 디자인 패턴입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_329",
      "title": "데이터베이스에서 인덱스를 생성하면 얻을 수 있는 장점 두 가지를 서술하시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "검색 성능 향상, 질의 처리 시간 단축",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "인덱스는 데이터 조회 속도를 향상시키고, 원하는 데이터를 찾는 질의(query)의 성능과 처리 속도를 크게 단축시킬 수 있습니다. 데이터 정렬보다는 검색 성능에 주된 효과가 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_330",
      "title": "데이터베이스에서 외래 키(Foreign Key)의 개념에 대해 간략히 서술하시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "한 테이블의 키 값이 다른 테이블의 기본 키를 참조하는 속성",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "외래 키는 한 테이블의 컬럼이 다른 테이블의 기본 키(primary key)를 참조하여 테이블 간의 관계를 연결합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_331",
      "title": "데이터베이스 트랜잭션의 격리성(Isolation)을 보장하기 위한 대표적 기술을 하나 쓰시오.",
      "subject": "데이터 입출력 구현",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "락킹(Locking)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "트랜잭션 격리성을 보장하기 위해 '락킹(Locking)' 기법을 사용하여 동시에 접근하는 트랜잭션 간의 간섭을 방지합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_332",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "38",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int[] nums = {3, 5, 7};\nSystem.out.print(nums[0]+nums[1]*nums[2]);",
      "answer": 1,
      "explanation": {
        "text": "자바 연산자는 곱셈(*)을 우선 수행하여 nums[1]*nums[2] = 35, 이후 nums[0]=3을 더하여 최종 38을 출력합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_333",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "7",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int x=10;\nfor(int i=0;i<3;i++){\n   x -= i;\n}\nSystem.out.print(x);",
      "answer": 1,
      "explanation": {
        "text": "반복문 수행 후 x 값은 10 - 0 - 1 - 2가 되어 최종 결과는 7입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_334",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "6",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n public static void main(String[] args) {\n int result = 1;\n for(int i=1; i<=3; i++) {\n result *= i;\n }\n System.out.println(result);\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "초기 result는 1입니다. 반복문을 1부터 3까지 돌며 result에 곱합니다.\n- i=1일 때 result = 1×1 = 1\n- i=2일 때 result = 1×2 = 2\n- i=3일 때 result = 2×3 = 6\n최종적으로 result는 6이 되어 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_335",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n public static void main(String[] args) {\n int[] nums = {4, 7, 9, 10};\n int count = 0;\n for(int n : nums) {\n if(n % 2 == 0) {\n count++;\n }\n }\n System.out.println(count);\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "배열 {4,7,9,10}을 반복하며 짝수만 찾습니다.\n- 4는 짝수 ➔ count=1\n- 7은 홀수 ➔ 통과\n- 9는 홀수 ➔ 통과\n- 10은 짝수 ➔ count=2\n따라서 최종 count는 2가 되어 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_336",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "9",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n static int add(int a, int b) {\n return a + b;\n }\n public static void main(String[] args) {\n int x = add(2, add(3,4));\n System.out.println(x);\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "메소드 add를 통해 계산합니다.\n- add(3,4)는 3+4=7\n- add(2,7)는 2+7=9\n따라서 최종적으로 9가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_337",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "cde",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n public static void main(String[] args) {\n String s = \"abcdefg\";\n System.out.println(s.substring(2, 5));\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "문자열 abcdefg\"에서 substring(2,5)는 인덱스 2부터 4까지 잘라냅니다.\n- 인덱스 2 = 'c'\n- 인덱스 3 = 'd'\n- 인덱스 4 = 'e'\n따라서 출력 결과는 \"cde\"입니다.\"",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_338",
      "title": "다음 Java 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "12",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n public static void main(String[] args) {\n int[] arr = {3, 6, 9, 12};\n int sum = 0;\n for(int i=0; i<arr.length; i+=2) {\n sum += arr[i];\n }\n System.out.println(sum);\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "배열 {3,6,9,12}에서 인덱스 0, 2의 값을 합산합니다.\n- i=0일 때 sum=3\n- i=2일 때 sum=3+9=12\n따라서 최종적으로 12가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_339",
      "title": "다음 Java 코드의 실행 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "15",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n public static void main(String[] args) {\n int a = 5, b = 10;\n System.out.println(a + b);\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "5와 10을 더하여 15가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_340",
      "title": "다음 C 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "12",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int a=5;\nprintf(%d\", a++ + ++a);\"",
      "answer": 1,
      "explanation": {
        "text": "C 코드에서 a++(후위 증감)은 5, ++a(전위 증감)은 증가된 값인 7로, 합산하여 12를 출력합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_341",
      "title": "다음 C 코드의 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "6",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "\"#include <stdio.h>\nint main() {\n int x = 2, y = 3;\n printf(\"%d\", x * y);\n return 0;\n}\"",
      "answer": 1,
      "explanation": {
        "text": "2와 3을 곱하여 6이 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_342",
      "title": "네트워크 공격 중, 허가된 사용자로 가장하여 네트워크 리소스를 사용하는 공격 방식은 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "스푸핑(Spoofing)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "스푸핑(Spoofing)은 공격자가 다른 사용자인 것처럼 가장하여 시스템에 접근하거나 데이터를 탈취하는 공격입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_343",
      "title": "객체지향 언어에서 한 클래스에서 여러 메소드를 같은 이름으로 정의하고, 매개변수의 타입이나 개수를 다르게 하는 기법은 무엇인가?",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "메소드 오버로딩(Method Overloading)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "메소드 오버로딩은 동일한 메소드 이름을 사용하지만 매개변수의 타입이나 개수를 달리하여 다양한 동작을 수행할 수 있게 하는 기법입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_344",
      "title": "객체 지향 프로그래밍(OOP)의 특성 중 '상속(Inheritance)'에 대해 간략히 설명하시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "AI 예상",
      "date": "",
      "choice1": {
        "text": "부모 클래스의 특성을 자식 클래스가 물려받는 것",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "상속은 기존 클래스(부모)의 속성과 기능을 새로운 클래스(자식)에서 물려받아 재사용하거나 확장하는 객체지향의 핵심 특성입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_345",
      "title": "다음은 파이썬 코드이다. 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "skiddp",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class good : li = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"] g = good() str01 = '' for i in g.li: str01 = str01 + i[0] print(str01)",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 good이라는 클래스를 정의하고, 클래스 변수 li에 여러 도시 이름을 담은 리스트를 저장합니다.\\n 이후 good 클래스의 인스턴스 g를 생성한 뒤, g.li를 통해 리스트에 접근합니다.\\n \\n str01이라는 문자열 변수는 처음에 빈 문자열로 초기화되어 있습니다.\\n 그리고 for 반복문을 이용하여 리스트 li에 들어 있는 각 도시 이름을 하나씩 꺼내옵니다.\\n 이때 꺼낸 도시 이름에서 첫 번째 문자(i[0])만을 추출하여 str01에 이어붙이는 방식으로 동작합니다.\\n \\n 리스트에 저장된 도시 이름들은 각각 \"seoul\", \"kyeonggi\", \"inchon\", \"daejeon\", \"daegu\", \"pusan\"입니다.\\n 각 도시 이름의 첫 글자는 차례대로 s, k, i, d, d, p입니다.\\n 이를 모두 이어붙이면 최종적으로 \"skiddp\"라는 문자열이 완성되며, print(str01)을 통해 화면에 출력됩니다.\\n \\n 결과적으로 이 프로그램의 출력 결과는 skiddp입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_346",
      "title": "다음 SQL 실행 결과를 숫자만 쓰시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "SELECT COUNT(*) FROM 급여\n\nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;",
      "answer": 1,
      "explanation": {
        "text": "주어진 데이터에 대해 SQL 쿼리를 실행하면, EMPNO > 100 AND SAL >= 3000 조건을 만족하는 행은 없고, EMPNO = 200 조건을 만족하는 행이 하나 있습니다. 이 조건에 맞는 행은 EMPNO가 200인 행입니다. 따라서, 쿼리 결과는 1개의 행이 조건을 만족하며, 최종적으로 출력되는 값은 1입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_347",
      "title": "다음 Java 프로그램 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "3\\n1\\n45\\n50\\n89",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);\n ",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램은 2차원 배열 arr을 생성하고, 배열의 각 요소에 대해 정보를 출력하는 코드입니다. arr 배열은 두 개의 하위 배열로 이루어져 있습니다. 첫 번째 하위 배열은 {45, 50, 75}이고, 두 번째 하위 배열은 {89}입니다. arr[0] 배열의 길이는 3이고, arr[1] 배열의 길이는 1입니다. 프로그램은 먼저 arr[0].length를 출력하는데, arr[0] 배열은 세 개의 원소를 가지고 있으므로 3이 출력됩니다. 그 다음으로 arr[1].length를 출력하는데, arr[1] 배열은 하나의 원소만 가지고 있으므로 1이 출력됩니다. 이어서 arr[0][0]을 출력하는데, arr[0] 배열의 첫 번째 원소는 45입니다. arr[0][1]은 arr[0] 배열의 두 번째 원소인 50을 출력하고, 마지막으로 arr[1][0]은 arr[1] 배열의 첫 번째 원소인 89를 출력합니다. 따라서 프로그램의 최종 출력 결과는 3, 1, 45, 50, 89입니다.\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_348",
      "title": "다음은 C언어 프로그램이다. 실행 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Lee\nn38",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n\nstruct good {\n        char name[10];\n    int age;\n };\n \n void main(){\n         struct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    \n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램은 struct good 구조체를 사용하여 여러 명의 정보를 저장하는 배열 s를 선언하고 있습니다. struct good은 이름(name)과 나이(age)를 포함하는 구조체입니다. 배열 s에는 네 명의 사람이 저장되어 있습니다:\\n\\n• 첫 번째 사람: 이름 \"Kim\", 나이 28\\n• 두 번째 사람: 이름 \"Lee\", 나이 38\\n• 세 번째 사람: 이름 \"Seo\", 나이 50\\n• 네 번째 사람: 이름 \"Park\", 나이 35\\n\\nstruct good *p는 구조체를 가리킬 포인터 p를 선언합니다. p는 처음에 배열 s의 첫 번째 요소를 가리키고, p++로 두 번째 요소로 이동합니다. 따라서, p는 배열 s의 두 번째 요소인 \"Lee\", 38을 가리키게 됩니다.\\n \\n p->name: p가 가리키는 두 번째 사람의 이름 \"Lee\"를 출력합니다.\\n p->age: p가 가리키는 두 번째 사람의 나이 38을 출력합니다.\\n \\n 따라서, 프로그램의 출력 결과는 \"Lee\"와 38이 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_349",
      "title": "다음은 Java 프로그램이다. 실행 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "0+1+2+3+4=15",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class good {\n        public static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n           System.out.print(\"+\");\n        }\n   }\n  }\n }",
      "answer": 1,
      "explanation": {
        "text": "위 Java 프로그램은 i와 j를 사용하여 반복문을 실행하면서 i 값을 출력하고 j 값을 누적하여 더합니다. i가 0부터 5까지 반복하며, 각 단계에서 i를 출력한 후 +를 출력하고, 마지막에는 =와 함께 누적된 j 값을 출력합니다. i 값은 0, 1, 2, 3, 4, 5 순으로 출력되며, j 값은 0, 1, 3, 6, 10, 15로 누적됩니다. 최종적으로 출력되는 결과는 0+1+2+3+4=15입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_350",
      "title": "다음 파이썬 비트 연산자 코드 결과를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "26",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a = 100\nresult = 0\nfor i in range(1,3);\n   result = a >> i\n   result = result + 1\npirnt(result)",
      "answer": 1,
      "explanation": {
        "text": "이 코드에서는 a를 오른쪽으로 비트 시프트한 후, 각 반복마다 result에 1을 더하는 방식으로 처리됩니다. 첫 번째 반복에서는 a를 1비트 시프트하여 50이 되고, 그 값에 1을 더해 51이 됩니다. 두 번째 반복에서는 a를 2비트 시프트하여 25가 되고, 그 값에 1을 더해 26이 됩니다. 따라서 출력되는 최종 결과는 26입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_351",
      "title": "다음은 C언어에 관한 소스코드이다. 실행 결과값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1024",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int main(){\n   int res;\n   res = mp(2,10);\n   printf(\"%d\",res);\n   return 0;\n}\n\nint mp(int base, int exp) {\n   int res = 1;\n   for(int i=0; i < exp; i++){\n      res = res * base;\n   }\n   \n   return res;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램에서 mp 함수는 주어진 base 값을 exp번 곱한 값을 반환하는 함수입니다. 함수의 흐름을 보면, res라는 변수는 1로 초기화되고, for 반복문을 통해 res에 base를 계속 곱합니다. 처음에 res = 1이고, for문이 실행되면서 res 값이 계속 갱신됩니다.\\n\\nmp(2, 10)이 호출되면, base는 2이고, exp는 10입니다.\\n반복문에서는 i가 0부터 9까지 증가하면서 res 값에 base를 곱합니다. 즉, res는 2번, 10번 곱해집니다.\\n반복문이 끝날 때, res의 값은 2^10, 즉 1024가 됩니다.\\n\\n 최종적으로, main 함수에서 mp(2, 10) 함수의 반환값인 1024를 출력하게 됩니다.\\n\\n따라서, 이 프로그램의 출력 결과는 1024입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_352",
      "title": "클래스 내에서 객체 생성 없이 사용할 수 있는 메소드로써 출력 결과를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "static",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Test {\n   public static void main(String[] args){\n      System.out.print(Test.check(1));\n   }\n   \n   (    )  String check (int num) {\n      return (num >= 0) ? \"positive\" : \"negative\";\n   }\n}\n",
      "answer": 1,
      "explanation": {
        "text": "이 문제에서 객체 생성 없이 check 메소드를 호출하려면, check 메소드는 static 메소드여야 합니다. 정적 메소드로 선언된 check(1)은 1이 0 이상이므로 \"positive\"를 반환합니다. 이 값은 System.out.print를 통해 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_353",
      "title": "다음은 C언어 문제이다. 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "8",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int main(){\n\nint ary[3];\nint s = 0;\n*(ary+0)=1;\nary[1] = *(ary+0)+2;\nary[2] = *ary+3;\nfor(int i=0; i<3; i++){\n  s=s+ary[i]\n}\n\nprint(\"%d\",s);\n\n}",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램은 배열의 값을 초기화하고 합산하는 프로그램입니다. 먼저 ary[0]에 1을 대입하고, ary[1]에는 ary[0] + 2를 대입하여 3을 저장합니다. ary[2]에는 ary[0] + 3을 대입하여 4를 저장합니다. 그 후, 배열의 모든 값을 합산하여 출력합니다. 배열의 값은 1, 3, 4로, 그 합은 8이므로 최종 출력값은 8입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_354",
      "title": "다음은 JAVA 관한 문제이다. 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "11",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class over1 {\n\tpublic static void main(String[] args){\n    \tovr1 a1 = new ovr1();\n        ovr2 a2 = new ovr2();\n        System.out.println(a1.sun(3,2) + a2.sun(3,2));\n    }\n    \n    int sun(int x, int y){\n    \treturn x + y;\n    }\n}\n\nclass ovr2 extends ovr1 {\n\n\tint sun(int x, int y){\n    \treturn x - y + super.sun(x,y);\n    }\n\n}",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램에서는 ovr1 클래스의 sun 메소드와 ovr2 클래스에서 오버라이드된 sun 메소드가 호출됩니다. 먼저, a1.sun(3, 2)는 ovr1 클래스의 sun 메소드를 호출하여 3 + 2 = 5를 반환합니다. 그 다음, a2.sun(3, 2)는 ovr2 클래스의 sun 메소드를 호출하는데, 여기서 부모 클래스의 sun(3, 2)를 호출하여 5를 더하고, 3 - 2 = 1을 더하여 결과적으로 6을 반환합니다. 최종적으로 두 값을 더한 5 + 6 = 11이 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_355",
      "title": "다음 Java 코드에 대한 알맞는 출력값을 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Connection {\n  private static Connection _inst = null;\n  private int count = 0;\n    static public Connection get() {\n      if(_inst == null) {\n      _inst = new Connection();\n      return _inst; \n      }\n    return _inst;\n    }\n  public void count() { count ++; }\n  public int getCount() { return count; }\n}\n \npublic class testcon {\n  public static void main(String[] args) {\n    Connection conn1 = Connection.get();\n    conn1.count();\n    Connection conn2 = Connection.get();\n    conn2.count();\n    Connection conn3 = Connection.get();\n    conn3.count();\n    \n    System.out.print(conn1.getCount());\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램은 싱글톤 패턴을 사용하여, Connection 클래스의 인스턴스를 단 하나만 생성하도록 합니다. Connection.get() 메소드를 호출할 때마다 동일한 인스턴스를 반환하므로, conn1, conn2, conn3 모두 동일한 인스턴스를 참조합니다. 각 객체에서 count를 증가시키는 count() 메소드가 호출되면, count 값이 누적되어 최종적으로 count 값은 3이 됩니다. 따라서, conn1.getCount()는 3을 반환하며 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_356",
      "title": "다음 Java 코드에 대한 알맞는 출력값을 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "7",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class testco {\n public static void main(String[] args) {\n  int a = 3, b = 4, c = 3, d = 5;\n  if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {\n   a = b + c;\n    if(7 == b ^ c != a) {\n     System.out.println(a);\n    } else {\n    System.out.println(b);\n    }\n  } else {\n    a = c + d;\n    if(7 == c ^ d != a) {\n    System.out.println(a);\n    } else {\n    System.out.println(d);\n    }\n  }\n }\n}",
      "answer": 1,
      "explanation": {
        "text": "이 프로그램에서는 여러 조건문과 비트 연산자가 사용됩니다. 첫 번째 조건문이 true로 평가되어 첫 번째 if 블록이 실행됩니다. a = b + c가 수행되면서 a는 7이 되고, 그 후 두 번째 조건문이 true로 평가되어 a를 출력하게 됩니다. 따라서 출력값은 7입니다.\\n• & : 비트연산자로써 같은 자리를 비교했을때 모두 같을 경우 True / 아니면 False\\n• | : 비트연산자로써 같은 자리를 비교했을때 하나라도 조건이 맞을 경우 True / 아니면 False\\n• ^ : XOR연산자로써 두 값이 같으면 False / 아니면 True",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_357",
      "title": "다음 C언어에 대한 알맞는 출력값을 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "37",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main(){\nint *arr[3];\nint a = 12, b = 24, c = 36;\narr[0] = &a;\narr[1] = &b;\narr[2] = &c;\n \nprintf(\"%d\\n\", *arr[1] + **arr + 1);\n \n}\n ",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 포인터 배열을 사용하여 배열 내 주소에 접근하고, 그 주소의 값을 이용해 연산을 수행하는 문제입니다. *arr[1]은 b의 값인 24를, **arr은 a의 값인 12를 가리키고, 이 값을 더한 뒤 1을 더하는 연산이 이루어집니다. 따라서 최종적으로 출력은 37이 됩니다.\\n•포인터 배열: 포인터 배열은 배열의 각 요소가 다른 변수의 주소를 저장하는 배열입니다.\\n•간접 참조 연산자 (*): 포인터가 가리키는 주소의 값을 참조하는 데 사용됩니다.\\n•이중 간접 참조 연산자 (**): 포인터가 가리키는 주소에서 다시 포인터를 참조하는 데 사용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_358",
      "title": "다음 파이썬 코드이다. 알맞는 출력값을 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "False",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a,b = 100, 200 \nprint(a==b)",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 파이썬에서 변수 a와 b에 각각 100과 200을 할당한 후, a == b라는 비교 연산자를 사용하여 두 값이 같은지 비교하는 문제입니다. a == b는 100 == 200을 비교하는 것으로, 결과는 False입니다.\\n•비교 연산자 (==): 두 값이 같은지 비교하여 같으면 True, 다르면 False를 반환합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_359",
      "title": "다음 C언어에 대한 알맞는 출력값을 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "501",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nstruct jsu {\n  char name[12];\n  int os, db, hab, hhab;\n};\n \nint main(){\nstruct jsu st[3] = {{\"데이터1\", 95, 88}, \n                    {\"데이터2\", 84, 91}, \n                    {\"데이터3\", 86, 75}};\nstruct jsu* p;\n \np = &st[0];\n \n(p + 1)->hab = (p + 1)->os + (p + 2)->db;\n(p + 1)->hhab = (p+1)->hab + p->os + p->db;\n \nprintf(\"%d\\n\", (p+1)->hab + (p+1)->hhab);\n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 포인터를 이용해 구조체 배열의 특정 요소에 접근하여 값을 연산하는 문제입니다.\\n먼저 구조체 배열 st가 초기화되며, p는 st[0]을 가리킵니다.\\n(p + 1)->hab는 st[1].os(84)와 st[2].db(75)를 더하여 159가 됩니다.\\n(p + 1)->hhab는 위에서 구한 159에 st[0].os(95)와 st[0].db(88)를 더해 계산하며, 159 + 95 + 88 = 342가 됩니다.\\n마지막으로 (p + 1)->hab + (p + 1)->hhab는 159 + 342 = 501이 되어 출력됩니다.\\n\\n•구조체(struct): 여러 개의 데이터를 하나의 단위로 묶을 수 있는 사용자 정의 자료형입니다.\\n•포인터(pointer): 변수의 메모리 주소를 저장하는 변수입니다.\\n•포인터 연산: 구조체 배열에서 포인터를 이용해 다음 구조체로 이동할 수 있습니다. (p+1)은 배열의 다음 요소를 가리킵니다.\\n•화살표 연산자(->): 포인터가 가리키는 구조체의 멤버에 접근할 때 사용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_360",
      "title": "다음 Java 문법에 알맞는 출력 결과를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "2000",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class A {\n  int a;\n  int b;\n}\n  \n  public class Main {\n  \n  static void func1(A m){\n   m.a *= 10;\n  }\n  \n  static void func2(A m){\n    m.a += m.b;\n  }\n  \n  public static void main(String args[]){\n  \n  A m = new A();\n  \n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  \n  System.out.printf(\"%d\", m.a);\n  \n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "우선 A라는 클래스는 int a, int b 두 개의 멤버 변수를 가지고 있습니다.\\nmain 메서드 안에서 A m = new A();를 통해 객체를 생성합니다.\\nm.a = 100;으로 a 값이 100으로 설정됩니다.\\n그 다음 func1(m);을 호출하면 m.a *= 10;이 실행되어 a 값은 100 * 10 = 1000이 됩니다.\\n이후 m.b = m.a;를 통해 b 값도 1000으로 설정됩니다.\\n그 다음 func2(m);을 호출하는데, m.a += m.b;가 실행되어 a 값에 b 값을 더하게 됩니다.\\n즉, 1000 + 1000 = 2000이 됩니다.\\n마지막으로 System.out.printf(\"%d\", m.a);를 호출하여 a 값을 출력하므로 최종 출력 결과는 2000입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_361",
      "title": "다음은 파이썬 코드에서 출력되는 a와 b의 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "a= 20 b= 2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "def exam(num1, num2=2):\n  print('a=', num1, 'b=', num2)\nexam(20)",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 Python의 기본 인자값을 사용하는 함수 호출에 관한 문제입니다.\\nexam 함수는 두 개의 매개변수를 받습니다. 첫 번째 매개변수 num1은 반드시 전달해야 하고, 두 번째 매개변수 num2는 기본값이 2로 설정되어 있습니다.\\n따라서 exam(20)을 호출하면 num1에 20이 전달되고, num2에는 기본값인 2가 사용됩니다.\\n결과적으로 print('a=', num1, 'b=', num2)가 실행되며, a= 20 b= 2가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_362",
      "title": "다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Car",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Car implements Runnable{\n  int a;\n  \n  public void run(){\n     system.out.println(\"message\")\n  }\n}\n  \npublic class Main{\n  public static void main(String args[]){\n    Thread t1 = new Thread(new ___());\n    t1.start();\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 Java에서 Runnable 인터페이스를 구현한 클래스를 쓰레드로 실행하는 코드입니다.\\nCar 클래스는 Runnable 인터페이스를 구현하고 있으며, run() 메서드를 오버라이드하여 message를 출력하는 코드가 작성되어 있습니다.\\nmain 메서드에서 Thread 객체를 생성할 때 new Thread(new ___())를 호출하고 있습니다.\\n이때 Thread는 Runnable 인터페이스를 구현한 객체를 인자로 받아야 하므로, 밑줄 부분에는 Car 클래스를 사용해야 합니다.\\n따라서 new Thread(new Car())로 작성하면, Car 클래스의 run() 메서드가 실행되어 message가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_363",
      "title": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "120",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\nint func(int a) {\n  if (a <= 1) return 1;\n  return a * func(a - 1);\n}\n \nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  printf(\"%d\", func(a));\n \n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 재귀 함수의 동작에 관한 문제입니다.\\n먼저 func 함수는 입력값 a가 1 이하일 경우 1을 반환하며, 그렇지 않으면 a와 func(a - 1)을 곱한 값을 반환합니다.\\n즉, 이 함수는 입력값이 주어지면 그 값에 대한 팩토리얼(factorial)을 계산하는 함수입니다.\\n입력값으로 5가 들어오면, func(5)는 5 * func(4)를 호출하고, func(4)는 4 * func(3)을 호출하는 방식으로 진행됩니다.\\n계속해서 func(3)은 3 * func(2)를 호출하고, func(2)는 2 * func(1)을 호출합니다.\\nfunc(1)은 1을 반환하므로, 최종적으로 5 * 4 * 3 * 2 * 1 = 120이 됩니다.\\n따라서 출력값은 120입니다.\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_364",
      "title": "다음 중, 괄호 ( ) 안에 들어갈 연산자를 써서 정수를 역순으로 출력하는 알맞는 답을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "(1) > (2) % (3) /",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\nint main() {\n \n  int number = 1234;\n  int div = 10;\n  int result = 0;\n \n  while (number ( 1 ) 0) {\n  \n    result = result * div;\n    result = result + number ( 2 ) div;\n    number = number ( 3 ) div;\n  \n  }\n \n  printf(\"%d\", result);\nreturn 0;\n \n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 정수를 역순으로 출력하는 코드입니다.\\n코드에서 number는 1234로 초기화되어 있으며, div는 10입니다. result는 0으로 초기화됩니다.\\n이 코드는 while 반복문을 사용하여 number를 각 자리수별로 나누고, result에 역순으로 자릿수를 더하는 방식으로 동작합니다.\\n첫 번째 연산자 (1)는 >입니다. 반복문은 number가 0보다 클 때까지 실행되므로 number > 0이 되어야 합니다.\\n두 번째 연산자 (2)는 %입니다. % 연산자는 number를 10으로 나눈 나머지, 즉 각 자릿수를 추출하는 데 사용됩니다.\\n세 번째 연산자 (3)는 /입니다. / 연산자는 number를 10으로 나누어 각 자리수를 하나씩 없애는 역할을 합니다.\\n따라서 결과적으로 1234가 역순으로 출력됩니다.\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_365",
      "title": "다음 소스코드가 실행할 때의 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "29",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h> \nint isPrime(int number) { \n  int i; \n  for (i=2; i<number; i++) { \n    if (number % i == 0) return 0; \n  } \n  return 1; \n} \n \nint main(void) { \n  int number = 13195, max_div=0, i; \n  for (i=2; i<number; i++) \n  if (isPrime(i) == 1 && number % i == 0) max_div = i; \n  printf(\"%d\", max_div); \n  return 0; \n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 주어진 number(13195)에 대해 가장 큰 소인수를 찾는 코드입니다.\\nisPrime 함수는 주어진 number가 소수인지 판별합니다. for 루프는 2부터 number - 1까지 모든 수에 대해 나누어떨어지는지 확인합니다. 만약 나누어떨어지면 소수가 아니므로 0을 반환하고, 그 외에는 소수이므로 1을 반환합니다.\\nmain 함수에서는 number(13195)에 대해 2부터 number - 1까지 반복하면서 isPrime(i) == 1 즉, 소수인 숫자 중에서 number를 나누어 떨어지게 만드는 가장 큰 소인수를 찾습니다.\\n이 과정에서 13195의 소인수는 5, 7, 13, 29가 있으며, 그 중 가장 큰 소인수는 29입니다.\\n따라서 출력값은 29입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_366",
      "title": "다음 Java 코드에 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "-8",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public static void main(String args[]){\n  \n  int i = 3; int k = 1; \n  switch(i) { \n    case 1: k += 1;\n    case 2: k++;\n    case 3: k = 0; \n    case 4: k += 3; \n    case 5: k -= 10; \n    default: k--; \n  }\n  System.out.print(k); \n  \n}\n ",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 Java의 switch 문에서 break가 없을 때, 각 case가 어떻게 순차적으로 실행되는지를 보여줍니다.\\n\n주어진 코드에서 i = 3이므로 switch(i) 문은 case 3으로 시작됩니다. 그런데 switch 문은 break가 없으면, 해당 case를 지나서 다음 case들도 계속 실행됩니다.\\n따라서 i가 3일 때, 코드 실행 흐름은 다음과 같습니다:\\ncase 3: k = 0;가 실행되면서 k의 값은 0이 됩니다.\\ncase 4: k += 3;가 실행되어 k는 0 + 3 = 3이 됩니다.\\ncase 5: k -= 10;가 실행되어 k는 3 - 10 = -7이 됩니다.\\ndefault: k--;가 실행되어 k는 -7 - 1 = -8이 됩니다.\\n\n따라서 최종적으로 k의 값은 -8입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_367",
      "title": "다음 소스코드에 대한 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "struct A{ \n  int n, \n  int g\n} \n \nint main(){\n  A a = new A[2] \n  for(i=0; i <2; i++) {\n    a[i].n = i, \n    a[i].g=i+1  \n  }\n  System.out.printf(a[0].n + a[1].g);  \n}",
      "answer": 1,
      "explanation": {
        "text": "A a = new A[2];로 A 객체 배열이 생성됩니다. a[0]과 a[1]은 각각 struct A 타입의 객체입니다.\\nfor (i = 0; i < 2; i++) 루프가 실행되며:\\n첫 번째 반복에서 i = 0일 때:\\na[0].n = 0; → a[0].n 값이 0으로 설정됩니다.\\na[0].g = 0 + 1; → a[0].g 값이 1로 설정됩니다.\\n두 번째 반복에서 i = 1일 때:\\na[1].n = 1; → a[1].n 값이 1로 설정됩니다.\\na[1].g = 1 + 1; → a[1].g 값이 2로 설정됩니다.\\nSystem.out.printf(a[0].n + a[1].g);가 호출됩니다.\\na[0].n은 0이고, a[1].g는 2이므로, 0 + 2 = 2가 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_368",
      "title": "다음은 파이썬 코드이다. 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "REMEMBER AND STR",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a = \"REMEMBER NOVEMBER\"\nb = a[:3] + a[12:16];\nc = \"R AND %s\" % \"STR\";\nprint(b+c);",
      "answer": 1,
      "explanation": {
        "text": "a = \"REMEMBER NOVEMBER\"\\na는 문자열 \"REMEMBER NOVEMBER\"로 정의됩니다.\\nb = a[:3] + a[12:16]\\na[:3]는 문자열 a의 처음부터 3번째 문자 전까지 추출하는 부분입니다. 즉, \"REM\"이 됩니다.\\na[12:16]는 a의 12번째 인덱스부터 15번째 인덱스까지의 문자를 추출하는 부분입니다. \"MBER\"가 됩니다.\\n따라서, b는 \"REM\" + \"MBER\" = \"REMMBER\"가 됩니다.\\nc = \"R AND %s\" % \"STR\"\\n%s는 문자열 포매팅입니다. \"STR\"이 %s 자리로 들어가므로, c는 \"R AND STR\"이 됩니다.\\nprint(b + c)\\nb + c는 \"REMMBER\"와 \"R AND STR\"을 이어붙이게 되므로, 출력값은 \"REMMBERR AND STR\"이 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_369",
      "title": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "10",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint len(char*p);\n \nint main(){\n \n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  \n  int a = len(p1);\n  int b = len(p2);\n  \n  printf(\"%d\", a + b);\n \n}\n \nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n }\n return r;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 주어진 C언어 코드에서 문자열의 길이를 계산하는 함수 len을 사용하여 두 문자열의 길이를 구한 후, 그 합을 출력하는 문제입니다.\\n\\n문자열 p1과 p2 정의\\n\\nc\\n복사\\n편집\\nchar* p1 = \"2022\";\\nchar* p2 = \"202207\";\\np1은 \"2022\"라는 문자열이고, 길이는 4입니다.\\n\\np2는 \"202207\"라는 문자열이고, 길이는 6입니다.\\n\\nlen 함수\\nlen 함수는 문자열 p의 길이를 구하는 함수입니다. while (*p != '\\0') 루프를 사용하여 문자열 끝에 있는 널 종료 문자 '\\0'까지 이동하면서 문자열의 길이를 계산합니다.\\n\\nlen(p1)은 \"2022\"의 길이 4를 반환합니다.\\n\\nlen(p2)은 \"202207\"의 길이 6을 반환합니다.\\n\\n합산된 길이 출력\\na + b는 len(p1) + len(p2)로, 즉 4 + 6 = 10입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_370",
      "title": "다음 C언어 코드에서 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "22",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main(int argc, char *argv[]) {\nint a[4] = {0, 2, 4, 8};\nint b[3] = {};\nint i = 1;\nint sum = 0;\nint *p1;\n \nfor (i; i < 4; i++) {\np1 = a + i;\nb[i-1] = *p1 - a[i-1];\nsum = sum + b[i-1] + a[i];\n}\n \nprintf(\"%d\", sum);\n \nreturn 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 C언어로 작성된 코드입니다.\\n 배열 a는 {0, 2, 4, 8}로 초기화되어 있고, 배열 b는 {0, 0, 0}으로 선언만 되어 있습니다.\\n 변수 i는 1로 초기화되어 있으며, sum은 0입니다.\\n for문은 i=1부터 i<4까지 반복합니다. 즉, i=1, i=2, i=3일 때 반복됩니다.\\n 반복문 내부에서는 포인터 p1이 a[i]를 가리키고, b[i-1]에 *p1 - a[i-1]을 저장합니다. 이후 sum에 b[i-1] + a[i]를 더합니다.\\n반복 과정을 하나씩 살펴보면 다음과 같습니다.\\ni=1일 때, p1은 a[1]을 가리킵니다. *p1은 2이고, a[0]은 0이므로 b[0] = 2 - 0 = 2입니다. 그 다음 sum = 0 + 2 + 2 = 4가 됩니다.\\n i=2일 때, p1은 a[2]를 가리킵니다. *p1은 4이고, a[1]은 2이므로 b[1] = 4 - 2 = 2입니다. 이후 sum = 4 + 2 + 4 = 10이 됩니다.\\n i=3일 때, p1은 a[3]을 가리킵니다. *p1은 8이고, a[2]는 4이므로 b[2] = 8 - 4 = 4입니다. 이후 sum = 10 + 4 + 8 = 22가 됩니다.\\n최종적으로 sum의 값은 22가 되어, printf(\"%d\", sum);을 통해 22가 출력됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_371",
      "title": "다음 자바코드에서 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "61",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Conv{ \npublic Conv(int a) {\nthis.a = a;\n} \nint func() {\nint b =1; \nfor (int i=1; i<a; i++){ \nb = a * i + b \n}\nreturn a +b;\n}\nint a;\n}\n \npublic static void main(String[] args){\nConv obj = new Conv(3);\nobj.a=5; \nint b = obj.func();\nsystem.out.print(obj.a + b);\ni\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 Java로 작성되었습니다.\\n Conv 클래스는 생성자로 a를 초기화하고, func() 메서드는 for문을 돌며 b = a * i + b를 계산합니다.\\n main() 함수에서 Conv obj = new Conv(3);로 생성하지만 바로 obj.a = 5;로 덮어씌웁니다.\\n 이후 obj.func() 호출 시 a = 5인 상태에서 b를 다음과 같이 갱신합니다.\\n i=1: b=6, i=2: b=16, i=3: b=31, i=4: b=51이 됩니다.\\n func()는 a + b = 5 + 51 = 56을 반환하고, b에 저장됩니다.\\n 마지막에 System.out.print(obj.a + b);를 출력하는데, obj.a=5이고 b=56이므로 출력은 61입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_372",
      "title": "아래는 C언어의 2차원 배열 형태이다. field의 경우 2차원 배열 형태는 예시처럼 출력되므로, 이를 참고하여 mines의 2차원 배열 형태를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1, 1, 3, 2\\n3, 4, 5, 3\\n3, 5, 6, 4\\n3, 5, 5, 3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "void main{\n \nfield {{0,1,0,1},{0,0,0,1},{1,1,1,0},{0,1,1,1}};\nmines {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}}; \n \nint w = 4, h = 4;\n  for(y=0; y<h; y++) {\n    for(x=0; x<w; x++) {  \n    if(field[y][x] == 0) continue;\n    \n      for(i=y-1; i<=y+1; i++) {\n        for(j=x-1; j<=x+1; j++) {\n          if(calculate(w,h,j,i) == 1) {\n            mines[i][j] += 1;\n          }\n        }\n      }\n    }\n  }\n  for(y=0; y<h; y++){\n    for(x=0; x<w; x++)\n      printf(\"%d\", mines[y][x]);\n      printf(\"\\n\");\n  }\n \n}\n \n \nint calculate(w,h,j,i) {\n  if (i >= 0 && i < h && j >= 0 && j < w) return 1;\n  return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성되었습니다.\\n 주어진 field 배열은 { {0,1,0,1}, {0,0,0,1}, {1,1,1,0}, {0,1,1,1} }입니다.\\n field[y][x]가 1인 경우, 그 주변 8칸(상하좌우대각선 포함)을 순회하면서 mines[i][j] 값을 1씩 증가시킵니다.\\n 단, 배열 범위를 벗어나지 않도록 calculate() 함수로 검사합니다.\\nfor문을 따라가며 하나씩 계산하면 다음과 같습니다.\\n\\n0,1)이 1 → 주변에 +1\\n(0,3)이 1 → 주변에 +1\\n(1,3)이 1 → 주변에 +1\\n(2,0),(2,1),(2,2)가 1 → 각 주변에 +1\\n(3,1),(3,2),(3,3)이 1 → 각 주변에 +1\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_373",
      "title": "아래 코드에 대한 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "24513",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "void main{\n \nint []result = int[5];\nint []arr = [77,32,10,99,50];\n \n  for(int i = 0; i < 5; i++) {\n    result[i] = 1;\n    for(int j = 0; j < 5; j++) {\n      if(arr[i] <arr[j]) result[i]++;\n    }\n  }\n \n  for(int k = 0; k < 5; k++) {\n    printf(result[k]);\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 배열 arr = [77, 32, 10, 99, 50]을 기준으로,\\n 각 원소보다 큰 값이 몇 개 있는지를 세어서 result[i]에 기록하는 구조입니다.\\n 초기에는 result[i]를 1로 설정하고,\\n for문을 통해 자기 자신을 제외한 다른 원소들과 비교해 더 큰 값이 발견될 때마다 +1을 합니다.\\ni=0일 때 77은 99보다만 작아 result[0]은 2가 됩니다.\\n i=1일 때 32는 77, 99, 50보다 작아 result[1]은 4가 됩니다.\\n i=2일 때 10은 77, 32, 99, 50 모두보다 작아 result[2]는 5가 됩니다.\\n i=3일 때 99는 어떤 값보다도 작지 않으므로 result[3]은 1입니다.\\n i=4일 때 50은 77과 99보다만 작아 result[4]는 3이 됩니다.\\n따라서 최종 출력은 2 4 5 1 3입니다.\\n 출력은 공백 없이 이어서 나오지만, 각 숫자는 위 순서대로 대응됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_374",
      "title": "다음 파이썬 코드에 대한 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "[101,102,103,104,105]",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "TestList = [1,2,3,4,5]\nTestList = list(map(lambda num : num + 100, TestList))\n \nprint(TestList)",
      "answer": 1,
      "explanation": {
        "text": "TestList = [1,2,3,4,5]로 리스트를 먼저 정의하고,\\n map 함수와 lambda를 이용해 리스트의 모든 요소에 100을 더하는 작업을 수행합니다.\\n map(lambda num: num + 100, TestList)는 TestList의 각 요소에 대해 100을 더한 결과를 생성합니다.\\n list()로 감싸서 최종 결과를 리스트 형태로 변환합니다.\\n최종적으로 TestList는 [101, 102, 103, 104, 105]가 되어 출력됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_375",
      "title": "STUDENT 테이블에서 컴퓨터과 학생 50명, 전기과 학생 100명, 인터넷과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과에 따른 튜플의 수는? (단, DEPT 칼럼은 학과명이다.)",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "(1) 200 (2) 3 (3) 1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "(1) SELECT DERP FROM STUDENT;\n\n(2) SELECT DISTINCT DEPT FROM STUDENT;\n\n(3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 SQL 언어에 대한 문제입니다.\\n STUDENT 테이블에는 컴퓨터과 50명, 전기과 100명, 인터넷과 50명, 총 200명의 학생 데이터가 저장되어 있습니다.\\n(1)SELECT DEPT FROM STUDENT;\\n 모든 학생의 DEPT 값을 선택합니다. 중복 제거가 없기 때문에 200명 모두 조회됩니다.\\n → 결과: 200개\\n(2)SELECT DISTINCT DEPT FROM STUDENT;\\n DEPT 컬럼에서 중복을 제거하고 학과명만 조회합니다. 현재 학과는 컴퓨터과, 전기과, 인터넷과 총 3개입니다.\\n → 결과: 3개\\n(3)SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';\\n WHERE 조건에 의해 DEPT가 '인터넷과'인 데이터만 대상으로 합니다. 이 조건에 맞는 DEPT 값은 모두 '인터넷과' 하나뿐입니다.\\n DISTINCT를 적용해도 결국 '인터넷과' 하나만 남기 때문에 COUNT 결과는 1입니다.\\n → 결과: 1개\\n\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_376",
      "title": "다음 코드에 대한 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int n;\nint k;\nint s;\nint el = 0;\n \n  for(n=6; n<=30; n++){\n    s=0;\n    k=n/2;\n    for(int j=1; j<=k; j++){\n      if(n%j==0){\n        s=s+j;\n      }\n    }\n    if(s==n){\n    el++;\n    }\n  }\n  \n  printf(\"%d\", el);",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성되었습니다.\\n 변수 n은 6부터 30까지 1씩 증가하며 반복합니다.\\n 각 n에 대해 1부터 n/2까지 약수를 모두 찾아 합한 값을 s에 저장합니다.\\n 만약 약수의 합 s가 자기 자신 n과 같으면 완전수(perfect number)로 판단해 el을 1 증가시킵니다.\\n6부터 30까지 완전수를 찾으면,\\n6: 약수 1,2,3 → 합 6 (완전수)\\n28: 약수 1,2,4,7,14 → 합 28 (완전수)\\n 이외의 숫자는 완전수가 아닙니다.\\n따라서 6과 28, 총 2개가 완전수입니다.\\n 마지막에 printf(\"%d\", el);을 통해 2를 출력합니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_377",
      "title": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "0123",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main {\n  static int[] MakeArray(){\n \n  int[] tempArr = new int[4];\n  \n  for(int i=0; i<tempArr.length;i++){\n    tempArr[i] = i;\n  }\n  \n  return tempArr;\n  }\n  \n  public static void main(String[] args){\n  \n  int[] intArr;\n  intArr = MakeArray();\n  \n  for(int i=0; i < intArr.length; i++)\n  System.out.print(intArr[i]);\n \n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 Java 언어로 작성되었습니다.\\n MakeArray() 메서드는 길이 4의 배열 tempArr를 생성하고,\\n for문을 통해 각 인덱스에 0부터 3까지 값을 넣습니다.\\n 즉, tempArr는 [0,1,2,3]이 됩니다.\\nmain 메서드에서는 MakeArray()를 호출해 intArr에 저장하고,\\n for문을 통해 배열의 모든 요소를 출력합니다.\\n 따라서 출력 순서대로 0, 1, 2, 3이 이어져 출력됩니다.\\n 최종 결과는 0123입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_378",
      "title": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "993",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Exam {\n  public static void main(String[] args){\n  \n  int a = 0;\n  for(int i=1; i<999; i++){\n    if(i%3==0 && i%2!=0)\n      a = i;\n    }\n    System.out.print(a);\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "코드는 i=1부터 i<999까지 반복하며,\\n 3의 배수이면서 짝수가 아닌 수를 찾습니다.\\n 찾을 때마다 변수 a를 갱신합니다.\\n 반복문은 i=998까지 실행되기 때문에 999는 포함되지 않습니다.\\n 따라서 마지막으로 조건을 만족하는 수는 993입니다.\\n 결국 출력값은 993이 됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_379",
      "title": "아래 자바 코드에서 출력되는 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "10\\n11\\n10\\n20\n\n ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Static{\n \n    public int a = 20;\n    static int b = 0;\n    \n}\n \npublic class Main{\n    public static void main(String[] args) {\n        \n        int a;\n        a = 10;\n        Static.b = a;\n \n        Static st = new Static();\n \n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}\n ",
      "answer": 1,
      "explanation": {
        "text": "먼저 Static 클래스는 a라는 인스턴스 변수(20)와 b라는 static 변수(0)를 가지고 있습니다.\\n main 함수에서는 지역변수 a를 10으로 설정하고,\\n static 변수인 Static.b에 a 값을 대입해 Static.b = 10이 됩니다.\\n그 다음 객체 st를 생성하지만, 이 과정은 static 변수 b에 영향을 주지 않습니다.\\nSystem.out.println(Static.b++);에서는 현재 b=10을 출력한 후, b를 1 증가시켜 b=11이 됩니다.\\n System.out.println(st.b);에서는 b가 static 변수이므로, 객체를 통해 접근해도 현재 값 11이 출력됩니다.\\n System.out.println(a);는 지역변수 a, 즉 10을 출력합니다.\\n System.out.print(st.a);는 객체 st의 인스턴스 변수 a 값인 20을 출력합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_380",
      "title": "다음 C언어의 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Art\\nA\\nA\\nArt\\nArt",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main(){\n\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n \n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n \n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n \n}\n",
      "answer": 1,
      "explanation": {
        "text": "문자 배열 a는 \"Art\"로 초기화되고,\\n 포인터 p는 a를 가리키게 됩니다.\\n첫 번째 printf(\"%s\\n\", a);는 배열 a를 문자열로 출력하므로 Art가 출력됩니다.\\n 두 번째 printf(\"%c\\n\", *p);는 포인터 p가 가리키는 첫 번째 문자, 즉 'A'를 출력합니다.\\n 세 번째 printf(\"%c\\n\", *a);는 배열 a의 첫 번째 원소, 역시 'A'를 출력합니다.\\n 네 번째 printf(\"%s\\n\", p);는 포인터 p가 가리키는 문자열 전체, 즉 Art를 출력합니다.\\n마지막 for문에서는 배열 a의 각 문자를 '\\0'이 나올 때까지 하나씩 출력합니다.\\n 따라서 'A', 'r', 't'가 연속해서 출력되며, 줄바꿈 없이 Art가 한 번 더 출력됩니다.\\n\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_381",
      "title": "다음 C언어의 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "qwe",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main(){\n \n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n \n    for(int i = 0; a[i] != '\\0' ; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n \n}\n",
      "answer": 1,
      "explanation": {
        "text": "char* a = \"qwer\";와 char* b = \"qwtety\";로 두 문자열을 선언했습니다.\\n for문 두 개를 사용하여 a의 각 문자에 대해 b의 모든 문자를 비교합니다.\\n a[i]와 b[j]가 같으면 그 문자를 출력합니다.\\n순서대로 살펴보면:\\na[0] = 'q'\\nb[0] = 'q' → 같으므로 'q' 출력\\na[1] = 'w'\\nb[1] = 'w' → 같으므로 'w' 출력\\na[2] = 'e'\\nb[2] = 't' (다름), b[3] = 'e' → 같으므로 'e' 출력\\na[3] = 'r'\\nb[0]~b[5] 어디에도 'r'은 없음 → 출력 없음\\n따라서 'q', 'w', 'e'가 출력됩니다.\\n최종 출력 결과는 qwe입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_382",
      "title": "다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "(a) %  (b) 10",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main() {\n \n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n \n    while (1) {\n \n        if (input == 0) break\n        else {\n \n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n \n        }\n    }\n \n    printf(\"%d\", sum);\n \n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "input = 101110은 십진수 형태로 입력된 이진수를 의미합니다.\\n while문 안에서 input의 마지막 자릿수를 하나씩 추출해 계산해야 합니다.\\n이를 위해 (input (a)(b)) 부분은 마지막 자리 숫자를 가져와야 하는데,\\n C언어에서 마지막 자리 숫자를 가져오는 방법은 **나머지 연산자(%)**를 사용하는 것입니다.\\n 따라서 (a)는 %, (b)는 10이 되어야 합니다.\\n 즉, input % 10은 현재 input의 가장 오른쪽 숫자를 의미합니다.\\n이 값을 di(2의 승수)와 곱해서 sum에 더하고,\\n di는 매번 2배로 키워줍니다 (2, 4, 8, 16처럼).\\n 그리고 input은 10으로 나누어 오른쪽 자리 수를 제거합니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_383",
      "title": "다음 코드에서 괄호안에 알맞는 값을 변수명으로 작성하시오. ",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "(1) idx2 (2) nx",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Sort {\n \n    public static void swap(int[] arr, int idx1, int idx2){\n        int temp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[( 1 )] = temp;\n    }\n \n    public static void Usort(int[] array, int length){\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length - i - 1; j++) {\n                if (array[j] > array[j + 1]) {\n                    swap(array, j, j + 1);\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        int[] item = new int[] { 5, 3, 8, 1, 2, 7 };\n        int nx = 6;   \n        Usort(item, ( 2 ));\n \n        for (int data : item) {\n            System.out.print(data + \" \");\n        }\n    }\n \n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 Java 언어로 작성된 버블 정렬(Bubble Sort) 코드입니다.\\n 먼저 swap 함수에서는 배열 arr의 idx1과 idx2 위치를 바꿔야 합니다.\\n 그런데 현재 코드에서는 arr[(1)] = temp;처럼 빈칸이 있는데,\\n 이 부분은 arr[idx2] = temp;로 완성해야 정상적인 swap이 됩니다.\\n 따라서 (1)에는 idx2가 들어갑니다.\\n\n\n다음으로 main 함수에서 Usort(item, (2)); 부분을 보면,\\n 배열 item은 {5, 3, 8, 1, 2, 7}로 총 6개의 원소를 가지고 있습니다.\\n nx = 6이기 때문에 Usort를 호출할 때는 배열의 길이 nx를 넘겨야 합니다.\\n 따라서 (2)에는 nx가 들어갑니다.\\n\n\n이렇게 코드를 완성하면 버블 정렬이 정상적으로 작동해서 배열을 오름차순 정렬하고,\\n 최종 출력은 1 2 3 5 7 8이 됩니다.\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_384",
      "title": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "{'한국', '중국', '베트남', '홍콩', '태국'}",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홍콩', '한국', '태국'})\nprint(a)",
      "answer": 1,
      "explanation": {
        "text": "초기에 a = {'한국', '중국', '일본'}으로 세트가 만들어집니다.\\n a.add('베트남')을 통해 '베트남'이 추가됩니다.\\n a.add('중국')을 다시 호출하지만, 세트(set)는 중복을 허용하지 않으므로 변화가 없습니다.\\n a.remove('일본')을 통해 '일본'이 삭제됩니다.\\n a.update({'홍콩', '한국', '태국'})을 통해 여러 항목을 추가합니다. 이미 있는 '한국'은 중복되어 추가되지 않습니다.\\n최종적으로 남는 항목은 '한국', '중국', '베트남', '홍콩', '태국'입니다.\\n set은 출력 시 순서가 정해져 있지 않지만,\\n 포함된 항목만 맞으면 정답입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_385",
      "title": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Vehicle name: Spark",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "abstact class Vehicle {\n \n    String name;\n    abstract public String getName(String val);\n \n    public String getName() {\n            return \"Vehicle name: \" + name;\n    }\n}\n \n \n \nclass Car extends Vehicle {\n \n    public Car(String val) {\n            name=super.name=val;\n    }\n \n    public String getName(String val) {\n            return \"Car name:\" + val;\n    }\n \n    public String getName(byte val[]) {\n            return \"Car name:\" + val;\n    }\n}\n \n \npublic class Main {\n \n    public static void main(String[] args) {\n \n    Vehicle obj = new Car(\"Spark\");\n    System.out.println(obj.getName());\n \n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "Vehicle 클래스는 추상 메서드 getName(String val)와,\\n 구현된 메서드 getName()을 가지고 있습니다.\\n Car 클래스는 Vehicle을 상속하며, 생성자에서 name 값을 설정합니다.\\n\n\nmain 함수에서 Vehicle obj = new Car(\"Spark\");를 통해\\n obj는 Car 객체지만 타입은 Vehicle로 선언되었습니다.\\n\n\nSystem.out.println(obj.getName());을 호출할 때는,\\n 매개변수가 없는 getName() 메서드가 호출됩니다.\\n (주의: 오버로딩된 메서드들 중 파라미터가 맞는 걸 호출함)\\n\n\nVehicle 클래스에 이미 매개변수 없는 getName()이 구현되어 있으므로,\\n Car에서 오버라이딩하지 않은 이상,\\n Vehicle 쪽 getName()이 실행됩니다.\\n\n\n따라서 결과는 \"Vehicle name: Spark\"가 출력됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_386",
      "title": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "500",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Parent {\n    int x = 100;\n \n    Parent() {\n        this(500);\n    }\n \n    Parent(int x) {\n        this.x = x;\n    }\n \n    int getX() {\n        return x;\n    }\n}\n \nclass Child extends Parent {\n    int x = 4000;\n    \n    Child() {\n        this(5000);\n    }\n \n    Child(int x) {\n        this.x = x;\n    }\n}\n \npublic class Main {\n    public static void main(String[] args) {\n        Child obj = new Child();\n        System.out.println(obj.getX());\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "Parent 클래스에는 x 필드와 두 개의 생성자가 있습니다.\\n 기본 생성자 Parent()는 this(500)을 호출해서,\\n Parent(int x) 생성자를 실행하고, 이때 부모 클래스의 x를 500으로 설정합니다.\\n\n\nChild 클래스는 Parent를 상속합니다.\\n Child도 기본 생성자에서 this(5000)을 호출해서\\n Child의 x를 5000으로 설정합니다.\\n 하지만 중요한 점은 Child의 x는 Child 클래스에 새로 선언된 변수이고,\\n Parent의 x와는 별개입니다.\\n\n\nmain() 함수에서는 Child obj = new Child();로 객체를 만들고\\n System.out.println(obj.getX());를 호출합니다.\\n\n\ngetX()는 Parent 클래스에 정의되어 있고,\\n Parent 클래스의 x 값을 반환합니다.\\n Child 클래스에는 getX()를 오버라이딩하지 않았기 때문입니다.\\n\n\n따라서 Parent 클래스의 x 값인 500이 출력됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_387",
      "title": "다음은 C언어 코드의 문제이다. 보기의 조건에 맞도록 괄호안에 알맞은 코드를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "n[(i+1) % 5]",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "int main(void) {\n \n    int n[5];\n    int i;\n \n    for (i = 0; i < 5; i++) {\n        printf(\"숫자를 입력해주세요 : \");\n        scanf(\"%d\", &n[i]);\n    }\n \n    for (i = 0; i < 5; i++) {\n        printf(\"%d\", (            ) );\n    }\n \n  return 0;\n \n}",
      "answer": 1,
      "explanation": {
        "text": "입력은 5개의 숫자를 차례대로 n[0]부터 n[4]까지 배열에 저장합니다.\\n 문제 조건은, 예를 들어 입력이 5 4 3 2 1이라면,\\n 출력은 4 3 2 1 5가 되어야 합니다.\\n\n\n즉, 배열을 한 칸씩 왼쪽으로 밀고, 맨 앞에 있던 값을 맨 마지막에 출력하는 효과를 내야 합니다.\\n\n\n이를 코드로 구현하려면,\\n i번째 출력할 때 i+1 번째 요소를 출력해야 하고,\\n i=4일 때는 n[5]가 아니라 다시 n[0]으로 돌아와야 합니다.\\n 이를 위해 (i+1)%5를 사용합니다.\\n\n\n결론적으로 printf(\"%d\", n[(i+1)%5]);로 작성하면 됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_388",
      "title": "다음은 JAVA 코드 문제이다. 가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "a = m / 1000\\nb = (m % 1000) / 500\\nc = (m % 1000 % 500) / 100\\nd = (m % 1000 % 500 % 100) / 10",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Problem{\n    public static void main(String[] args){\n m = 4620;\n \n a = (              );\n b = (              );\n c = (              );\n d = (              );\n \n System.out.println(a); //천원짜리     4장 출력\n System.out.println(b); //오백원짜리  1개 출력\n System.out.println(c); //백원짜리     1개 출력\n System.out.println(d); //십원짜리     2개 출력\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "총 4620원을 1000원, 500원, 100원, 10원 단위로 최대한 적게 나누어야 합니다.\\n\n\n먼저 1000원권 개수는 m / 1000으로 계산합니다.\\n 그 다음 1000원으로 나눈 나머지 금액에 대해 500원 개수를 계산합니다: (m % 1000) / 500\\n 500원까지 제외한 나머지 금액으로 100원 개수를 계산합니다: (m % 1000 % 500) / 100\\n 100원까지 제외한 나머지 금액으로 10원 개수를 계산합니다: (m % 1000 % 500 % 100) / 10\\n\n\n실제 계산 흐름은 다음과 같습니다:\\n\n\n4620 ÷ 1000 → 4장 (잔액 620)\\n\n\n620 ÷ 500 → 1개 (잔액 120)\\n\n\n120 ÷ 100 → 1개 (잔액 20)\\n\n\n20 ÷ 10 → 2개\\n\n\n따라서 출력은 4, 1, 1, 2가 됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_389",
      "title": "다음은 c언어의 코드이다. 보기의 조건에 맞추어 알맞은 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "박영희\\n박영희\\n박영희",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include<stdlio.h> \n#include<stdlib.h> \nchar n[30];\nchar *test() {\n    printf(입력하세요 : );\n    gets(n);\n    return n;\n}\n \nint main()\n \n{\n    char * test1;\n    char * test2;\n    char * test3;\n \n    test1 = test();\n    test2 = test();\n    test3 = test();\n \n    printf(%s\\n,test1);\n    printf(%s\\n,test2);\n    printf(%s,test3);\n \n}",
      "answer": 1,
      "explanation": {
        "text": "char n[30];는 전역 변수로 선언되어 있고,\\n test() 함수는 전역 변수 n에 입력받은 문자열을 저장하고,\\n 그 주소를 반환합니다.\\nmain 함수에서는 test1, test2, test3가 각각 test()의 반환값을 받습니다.\\n 하지만 중요한 점은, 세 포인터 모두 같은 n 배열을 가리킨다는 점입니다.\\n즉, test1, test2, test3 모두 n을 가리키고 있습니다.\\n n은 홍길동, 김철수, 박영희 순서대로 세 번 덮어쓰여집니다.\\n 마지막 입력인 박영희로 n 배열이 덮어써지기 때문에,\\n 결국 test1, test2, test3 모두 박영희를 가리키게 됩니다.\\n따라서 출력 결과는 모두 박영희입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_390",
      "title": "다음은 C언어의 문제이다. 알맞은 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "BCD",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n \n    for(int i=0;i<3;i++){\n        sum += n[i];\n    }\n \n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "배열 합계는 250,\\n 250 ÷ 30 = 8로 계산되어 switch(8)으로 진입합니다.\\n case 8에서 \"B\"를 출력하고,\\n break가 없어서 case 7로 넘어갑니다.\\n case 7은 바로 case 6으로 넘어가서 \"C\"를 출력하고,\\n 다시 break가 없어서 default로 가서 \"D\"를 출력합니다.\\n 따라서 최종 출력은 BCD입니다.\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_391",
      "title": "다음은 소스코드의 알맞은 출력을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "505",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main(){\n \n    int c = 0;\n \n    for(int i = 1; i <=2023; i++) { \n      if(i%4 == 0) c++; \n    }\n    printf(\"%d\", c);\n}\n ",
      "answer": 1,
      "explanation": {
        "text": "for문을 통해 1부터 2023까지 모든 수를 검사하면서,\\n 4의 배수일 때마다 카운트(c)를 1씩 증가시킵니다.\\n4의 배수는 4, 8, 12, ..., 2020 이렇게 나오게 됩니다.\\n1부터 2023까지 4의 배수 개수는:\\n2023 ÷ 4 = 505.75 → 몫은 505\\n 즉, 1부터 2023까지 4의 배수는 505개입니다.\\n\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_392",
      "title": "다음은 C언어 문제이다. 알맞은 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "213465",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n#define MAX_SIZE 10\n \nint isWhat[MAX_SIZE];\nint point= -1;\n \nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\n \nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\n \nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    else isWhat[++point] = num;\n}\n \nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    else return isWhat[point--];\n    return 0;\n}\n \nint main(int argc, char const *argv[]){\n    int e;\n    into(5); into(2);\n \n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take());\n        into(3); printf(\"%d\", take()); printf(\"%d\", take());\n        into(6); printf(\"%d\", take()); printf(\"%d\", take());\n    }\n    \n    return 0;\n}\n",
      "answer": 1,
      "explanation": {
        "text": "초기에 5, 2를 스택에 넣고,\\n 2를 꺼낸 뒤, 4와 1을 넣고 1을 꺼냅니다.\\n 3을 넣고 3과 4를 차례로 꺼냅니다.\\n 6을 넣고 6과 5를 꺼냅니다.\\n 따라서 출력 순서는 2, 1, 3, 4, 6, 5가 됩니다.\\n 최종 출력은 213465입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_393",
      "title": "다음은 자바에 대한 문제이다. 알맞은 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "true\\nfalse\\ntrue\\ntrue",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main{\n    public static void main(String[] args) {\n        \n        String str1 = \"Programming\";\n        String str2 = \"Programming\";\n        String str3 = new String(\"Programming\");\n        \n        println(str1==str2)\n        println(str1==str3)\n        println(str1.equals(str3))\n        print(str2.equals(str3))\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "문자열 str1, str2는 둘 다 \"Programming\"이라는 리터럴을 직접 할당했습니다.\\n Java에서는 문자열 리터럴이 같으면 같은 객체를 참조합니다.\\n 따라서 str1 == str2는 true가 됩니다.\\n하지만 str3은 new String(\"Programming\")으로 생성했기 때문에,\\n Heap 메모리에 새로운 객체를 생성합니다.\\n 그래서 str1 == str3는 false입니다. (참조가 다름)\\n반면 equals() 메서드는 문자열의 내용을 비교합니다.\\n str1.equals(str3)와 str2.equals(str3)는 둘 다 문자열이 \"Programming\"으로 같기 때문에 true입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_394",
      "title": "다음 코드는 선택정렬 구현에 관한 문제이다.  오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n ",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": ">",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include\nint main() {\n    int E[] = {64, 25, 12, 22, 11};\n    int n = sizeof(E) / sizeof(E[0]);\n    int i = 0;\n    do {\n        int j = i + 1;\n        do {\n            if (E[i] (     ) E[j]) {\n                int tmp = E[i];\n                E[i] = E[j];\n                E[j] = tmp;\n            }\n            j++;\n        } while (j < n);\n        i++;\n    } while (i < n-1);\n    for(int i=0; i<=4; i++)\n        printf(\"%d \", E[i]);\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성된 선택 정렬(Selection Sort) 구현입니다.\\n 선택 정렬은 현재 위치에서 가장 작은 값을 선택해 앞으로 가져오는 방식입니다.\\n오름차순으로 정렬하려면,\\n 현재 비교하는 두 값 중 앞쪽 값이 크면 둘을 교환해야 합니다.\\n즉, if (E[i] > E[j])가 되어야 합니다.\\nE[i]가 E[j]보다 크다면, 더 작은 값인 E[j]를 앞으로 가져와야 합니다.\\n보기에 있는 선택지 중에서\\n<, <=, =>, ==, /, %는 오름차순 비교 조건에 적합하지 않습니다.\\n>만이 \"앞의 값이 클 때 교환\"하는 오름차순 조건에 맞습니다.\\n따라서 빈칸에는 **>**를 작성해야 합니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_395",
      "title": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "engneing",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a = \"engineer information processing\"\nb = a[:3]\nc = a[4:6]\nd = a[28:]\ne=b+c+d\nprint(e)",
      "answer": 1,
      "explanation": {
        "text": "먼저 a는 \"engineer information processing\"이라는 문자열입니다.\\n b = a[:3]은 인덱스 0부터 2까지 잘라서 \"eng\"를 가져옵니다.\\n c = a[4:6]은 인덱스 4부터 5까지 잘라서 \"ne\"를 가져옵니다.\\n d = a[28:]은 인덱스 28부터 끝까지 가져오는데,\\n 28번째 문자부터는 \"ing\"가 됩니다.\\n 따라서 e는 \"eng\" + \"ne\" + \"ing\"이 되어 \"engneing\"이 됩니다.\\n 최종적으로 출력 결과는 engneing입니다.\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_396",
      "title": "다음은 Java 코드이다. 올바른 출력 결과를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "BDCDD",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class main{\n    public static void main(String[] args) {\n        A b = new B();\n        b.paint();\n        b.draw();\n    }\n}\n \nclass A {\n    public void paint() {\n        System.out.print(\"A\");\n        draw();\n    }\n    public void draw() {\n        System.out.print(\"B\");\n        draw();\n    }\n}\n \nclass B extends A {\n    public void paint() {\n        super.draw();\n        System.out.print(\"C\");\n        this.draw();\n    }\n    public void draw() {\n        System.out.print(\"D\");\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "b.paint()를 호출하면 B의 paint()가 실행됩니다.\\n super.draw() 호출 시 A의 draw()를 실행하는데,\\n A의 draw()는 먼저 \"B\"를 출력하고,\\n draw()를 다시 호출하여 B의 draw()를 호출하고 \"D\"를 출력합니다.\\n 그 다음 \"C\"를 출력하고,\\n this.draw()로 다시 B의 draw()를 호출하여 \"D\"를 출력합니다.\\n 마지막으로 b.draw() 호출 시 B의 draw()를 실행하여 \"D\"를 출력합니다.\\n 따라서 최종 출력은 BDCDD가 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_397",
      "title": "다음은 C 언어 코드이다. 알맞는 출력 결과를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "34",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint test(int n) {\n    int i, sum = 0;\n \n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n \n    if (n == sum) \n        return 1;\n    ​\n    return 0;\n}\n \n \nint main(){\n    int i, sum=0;\n \n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n    \n    printf(\"%d \", sum); \n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성된 완전수(perfect number) 검사 프로그램입니다.test(n) 함수는 주어진 수 n이 완전수인지 확인합니다.완전수란, 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수를 의미합니다.\\nfor (i = 2; i <= 100; i++) 반복문을 돌면서 2부터 100까지의 수 중,\\n 완전수인 경우 그 값을 sum에 누적합니다.\\n100 이하의 완전수는 6과 28 두 개뿐입니다.\\n6의 약수: 1, 2, 3 → 합: 6\\n28의 약수: 1, 2, 4, 7, 14 → 합: 28\\n따라서 sum = 6 + 28 = 34가 됩니다.\\n최종적으로 출력값은 34입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_398",
      "title": "C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 기호를 작성하시오. ",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "→",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n \nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n   d2 ( ) numPtr = &num; \n \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n \n    free(d2); \n    return 0;\n}\n \n",
      "answer": 1,
      "explanation": {
        "text": "구조체 Data에는 char c와 int* numPtr 두 개의 멤버가 있습니다.\\nd1은 구조체 자체이고, d2는 구조체 포인터입니다.\\n구조체 변수(d1)의 멤버에 접근할 때는 마침표 .을 사용합니다.\\n구조체 포인터(d2)의 멤버에 접근할 때는 화살표 ->를 사용합니다.\\n문제 코드에서는:\\nd1.numPtr = &num; → d1은 변수이므로 . 사용\\nd2 ( ) numPtr = &num; → d2는 포인터이므로 ( )에 들어갈 것은 ->\\n또한 printf 부분에서도\\n\\*d1.numPtr은 OK\\n*d2 ( ) numPtr에서도 ( )에 ->가 들어가야 합니다.\\n따라서 괄호 안에는 모두 **->**가 들어가야 합니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_399",
      "title": "다음 C언어 코드에 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "5040",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include\n \nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\n \nint main() {\n    printf(\"%d\", f(7));\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성된 팩토리얼(factorial) 함수입니다.\\n 함수 f(n)은 n이 1 이하일 경우 1을 반환하고,\\n 그 외에는 n * f(n-1)을 재귀 호출합니다.\\n즉, 이 함수는 **n! (n팩토리얼)**을 계산하는 함수입니다.\\nf(7)을 계산하면:\\n7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040\\n따라서 printf(\"%d\", f(7));은 5040을 출력합니다.\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_400",
      "title": "다음은 C언어의 포인터 문제이다. 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "KOREA\\nOREA\\nK\\nE\\nO",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include\n \nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s\\n\", p);\n    printf(\"%s\\n\", p+1);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *(p+3));\n    printf(\"%c\\n\", *p+4);\n}\n ",
      "answer": 1,
      "explanation": {
        "text": "이 코드는 C언어로 작성된 포인터와 문자열 출력 문제입니다.\\n 먼저 char* p = \"KOREA\";는 문자열 상수를 가리키는 포인터 p를 선언합니다.\\n각 출력문을 분석하면:\\nprintf(\"%s\\n\", p);\\n포인터 p가 가리키는 문자열 전체 \"KOREA\"를 출력합니다.\\nprintf(\"%s\\n\", p+1);\\np+1은 p가 가리키는 주소에서 한 글자 뒤를 가리킵니다.\\n따라서 \"OREA\"가 출력됩니다.\\nprintf(\"%c\\n\", *p);\\n*p는 p가 가리키는 첫 번째 문자, 즉 'K'를 출력합니다.\\nprintf(\"%c\\n\", *(p+3));\\np+3은 p에서 3칸 뒤를 가리킵니다.\\n즉, 'E'를 출력합니다.\\nprintf(\"%c\\n\", *p+4);\\n*p는 'K'인데, 여기에 정수 4를 더합니다.\\n'K'의 아스키코드값은 75\\n75 + 4 = 79\\n아스키코드 79는 'O'입니다.\\n따라서 'O'가 출력됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_401",
      "title": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\n \nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\n \npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}\n",
      "answer": 1,
      "explanation": {
        "text": "Child 클래스의 compute 메서드는 num-1과 num-3을 더하는 구조입니다.\\n obj.compute(7)을 계산하면,\\n compute(6) + compute(4) 순서로 계산이 진행됩니다.\\n 하위 호출을 재귀적으로 전개하면 최종 결과는 2가 됩니다.\\n 따라서 출력은 2입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_402",
      "title": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "7",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Person {\n    private String name;\n    public Person(String val) {\n        name = val;\n    }\n    public static String get() {\n    return name;\n    }\n    public void print() {\n        System.out.println(name);\n    }\n}\npublic class main {\n    public static void main(String[] args) {\n        Person obj = new Person(\"Kim\");\n        obj.print();\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "static 메서드에서는 인스턴스 변수를 직접 사용할 수 없습니다.\\n name은 인스턴스 변수인데 static 메서드 get()에서 직접 접근하려고 해서,\\n 컴파일 에러가 발생합니다.\\n 에러가 발생하는 정확한 위치는 7번째 줄인 return name;입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_403",
      "title": "다음은 파이썬에 대한 문제이다. 괄호 안에 알맞는 답을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "split()",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "print(\"파이썬 입출력에 대한 문제입니다.\")\n \nnum1, num2 = input()._____()\nnum1 = int(num1)\nnum2 = int(num2)\nprint(num1,num2)\n \nnum3 = num1 + num2\nprint(num1 + \" + \"  + num2 + \" = \" + num3)",
      "answer": 1,
      "explanation": {
        "text": "Python에서는 input()으로 입력받은 문자열을 공백 기준으로 나누기 위해 split()을 사용합니다.\\n split은 메서드 이름이고,\\n split()처럼 괄호를 붙여야 실제로 문자열을 나누는 동작이 실행됩니다.\\n 따라서 정답은 **split()**입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_404",
      "title": "ICMP, 송신 주소를 공격 대상의 IP 주소로 위장하고, 수신 주소를 해당 네트워크 라우터의 브로드캐스트 주소로 설정하는 공격으로 과부화 시키는 기법은? ICMP 패킷을 크게 만들어서 과부화 시키는 죽음의 핑과 같은 서비스 공격 유형이다.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "스머핑(Smurfing)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**스머프(Smurf) 또는 스머핑(Smurfing)**\\n• IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격입니다.\\n• 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격입니다.\\n• 공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠집니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_405",
      "title": "인터넷을 통해 장치 간 사설 네트워크 연결을 생성하는 서비스로  장치의 실제 IP 주소를 가상 IP 주소로 대체하고, 데이터를 암호화하고, 데이터를 전 세계 보안 네트워크로 라우팅함으로써 정보를 보호하는 기법은?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "VPN",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**VPN**\\n• 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\\n• 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만듭니다.\\n• 종류로는 IPsec 또는 SSL, L2TP 등이 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_406",
      "title": "(         ) 패턴은 객체 간의 상호 작용하는 방법과 책임을 분배하는 방법에 중점을 두는 디자인 패턴으로 Command, Interpreter, Memento, Observer, Visitor등이 존재한다. 괄호 (    ) 안에 들어갈 용어를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "행위",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "행위 패턴(Behavioral Pattern)은 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들을 의미합니다. 디자인 패턴으로 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)가 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_407",
      "title": "(         ) 무결성은 데이터베이스의 테이블에서 기본 키(Primary Key) 값을 반드시 유일하고 NULL이 아니게 유지해야 한다는 규칙을 의미한다. 괄호 (    ) 안에 들어갈 용어를 쓰시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "개체",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "데이터베이스 무결성은 데이터의 일관성과 정확성을 유지하기 위한 규칙 및 제약 조건의 집합으로, 아래 3가지 유형으로 가장 많이 언급됩니다.\\n• **개체 무결성 (Entity Integrity)** : 테이블의 각 행이 고유하게 식별될 수 있도록 하는 제약 조건으로, 주로 기본 키(primary key)를 사용해 한 행의 식별자를 null로 설정하지 못하게 하여 데이터의 무결성을 보장합니다.\\n• **참조 무결성 (Referential Integrity)** : 테이블 간의 관계에서 외래 키(foreign key)를 통해 데이터의 일관성을 보장합니다. 외래 키 값은 반드시 참조하는 테이블의 기본 키 값을 가져야 하며, 이를 통해 두 테이블 간의 관계가 깨지지 않도록 합니다.\\n• **도메인 무결성 (Domain Integrity)** : 각 속성(컬럼)이 특정한 데이터 타입과 값의 범위를 가지도록 하는 제약입니다. 이는 속성에 허용되는 값이 미리 정의된 도메인 내에 있어야 하며, 데이터 타입이나 NULL 값의 사용 여부 등을 제한합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_408",
      "title": "다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "OOAAA",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main{\n  static String[] s = new String[3];\n \n  static void func(String[]s, int size){\n    for(int i=1; i<size; i++){\n      if(s[i-1].equals(s[i])){\n        System.out.print(\"O\");\n      }else{\n        System.out.print(\"N\");\n      }\n    }\n      for (String m : s){\n        System.out.print(m);\n      }\n    }\n  \n \n  public static void main(String[] args){\n    s[0] = \"A\";\n    s[1] = \"A\";\n    s[2] = new String(\"A\");\n \n    func(s, 3);\n  }\n}",
      "answer": 1,
      "explanation": {
        "text": "1.main 메소드에서:\\n• s[0]에 문자열 리터럴 \"A\"를 할당합니다.\\n• s[1]에도 같은 문자열 리터럴 \"A\"를 할당합니다. Java에서는 같은 문자열 리터럴은 String Pool에서 같은 객체를 참조합니다.\\n• s[2]에는 new String(\"A\")로 새로운 문자열 객체를 생성하여 할당합니다. 이는 내용은 같지만 다른 메모리 주소에 위치한 별개의 객체입니다.\\n\\n2.func(s, 3) 메소드 호출:\\n• 첫 번째 반복 (i=1):\\n• s[0]와 s[1]을 equals 메소드로 비교합니다.\\n• 두 문자열의 내용이 모두 \"A\"로 동일하므로 true 반환하여 \"O\" 출력합니다.\\n• 두 번째 반복 (i=2):\\n• s[1]과 s[2]를 비교합니다.\\n• s[2]는 new로 생성된 별개의 객체이지만, equals 메소드는 내용만 비교하므로 둘 다 \"A\"여서 true 반환, \"O\" 출력합니다.\\n• (만약 == 연산자로 비교했다면 객체 참조가 달라 false가 반환되었을 것입니다)\\n\\n3.향상된 for문에서 배열의 모든 요소 출력:\\n• s[0] 출력: \"A\"\\n• s[1] 출력: \"A\"\\n• s[2] 출력: \"A\"\\n\\n최종 출력: \"OOAAA\"",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_409",
      "title": "다음은 파이썬에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "3",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "def func(lst):\n  for i in range(len(lst) //2):\n    lst[i], lst[-i-1] = lst[-i-1], lst[i]\n \nlst = [1,2,3,4,5,6] \nfunc(lst)\nprint(sum(lst[::2]) - sum(lst[1::2]))",
      "answer": 1,
      "explanation": {
        "text": "1.초기 리스트: lst = [1,2,3,4,5,6]\\n2. func(lst) 함수 실행:\\n• range(len(lst) // 2) = range(6 // 2) = range(3) 이므로 i는 0, 1, 2 값을 가집니다.\\n3. 각 반복에서의 교환 과정:\\n• i = 0: lst[0]과 lst[-1]을 교환 → lst = [6,2,3,4,5,1]\\n• i = 1: lst[1]과 lst[-2]를 교환 → lst = [6,5,3,4,2,1]\n\\n• i = 2: lst[2]과 lst[-3]을 교환 → lst = [6,5,4,3,2,1]\\n4. 함수 실행 후, lst는 원래 리스트가 완전히 뒤집힌 상태: [6,5,4,3,2,1]\\n5. 마지막 계산:\\n• lst[::2] = [6,4,2] (인덱스 0, 2, 4의 요소들)\\n• lst[1::2] = [5,3,1] (인덱스 1, 3, 5의 요소들)\\n• sum(lst[::2]) = 6 + 4 + 2 = 12\\n• sum(lst[1::2]) = 5 + 3 + 1 = 9\\n• 12 - 9 = 3\\n\\n따라서 최종 출력값은 3입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_410",
      "title": "아래의 employee테이블과 project테이블을 참고하여 보기의 SQL명령어에 알맞는 출력 값을 작성하시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "SELECT \n    count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p WHERE p.project_id IN (\n        SELECT project_id FROM employee GROUP BY project_id HAVING count(*) < 2\n    )\n);\n",
      "answer": 1,
      "explanation": {
        "text": "주어진 SQL 쿼리는 직원 테이블(employee)과 프로젝트 테이블(project)을 사용하여 특정 조건을 만족하는 데이터의 개수를 계산합니다. 단계별로 분석해보겠습니다.\\n\\n1.가장 안쪽 서브쿼리부터 시작:\\n• employee 테이블에서 project_id로 그룹화\\n• 각 그룹의 직원 수가 2명 미만인 경우만 선택\\n• employee 테이블에서 각 project_id별 인원 수:\\n• project_id 10: 2명 (John, Rachel)\\n• project_id 20: 1명 (Jim)\\n• 따라서 직원이 1명인 project_id 20만 반환됩니다.\\n\\n2. 중간 서브쿼리:\\n• project 테이블에서 project_id가 20인 프로젝트의 이름을 찾음\\n• 이는 \"Beta\" 프로젝트입니다.\\n\\n3.메인 쿼리:\\n• employee와 project 테이블을 project_id로 조인\\n• 프로젝트 이름이 \"Beta\"인 경우만 선택\\n• 이 조건을 만족하는 행은 Jim이 참여하는 Beta 프로젝트 하나뿐입니다.\\n\\n따라서 최종 출력값은 1입니다.주의할 점: project 테이블에 project_id=10이 두 번 나타나지만(Alpha와 Gamma), SQL 서브쿼리에서는 결과에 영향을 주지 않습니다. 중요한 점은 employee 테이블에서 project_id=20인 직원이 1명뿐이라는 것입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_411",
      "title": "다음 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU 알고리즘의 페이지 부재 횟수를 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "12",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "이 문제는 LRU(Least Recently Used) 알고리즘을 사용하는 페이지 교체 방식에서 페이지 부재 횟수를 계산하는 문제입니다.\nLRU 알고리즘은 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다. 주어진 조건을 정리해보면:\\n페이지 참조 순서: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1\\n프레임 수(메모리 크기): 3개\\n페이지 부재(Page Fault)가 발생한 횟수를 세어보면: 7, 0, 1, 2, 3, 0, 4, 2, 3, 0, 1, 2, 7, 0, 1에서 발생하여 총 12번입니다.따라서 LRU 알고리즘을 사용할 때 페이지 부재 횟수는 12입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_412",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "20",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint func(){\n static int x =0; \n  x+=2; \n  return x;\n}\n \nint main(){\n  int x = 1; \n  int sum=0; \n  for(int i=0;i<4;i++) {\n    x++; \n    sum+=func();\n  } \n  printf(\"%d\", sum);\n \n  return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "이 코드의 실행 과정을 단계별로 추적해 보겠습니다:\\n\\n1. main() 함수에서:\\n• x를 1로 초기화\\n• sum을 0으로 초기화\\n• i가 0부터 3까지 반복하는 for 루프 시작\\n\\n2. 반복문 내부:\\n• main() 함수의 지역 변수 x를 1씩 증가시킴\\n• func() 함수를 호출하고 그 반환값을 sum에 더함\\n\\n3. func() 함수는:\\n• static int x = 0으로 정적 변수 선언 (프로그램 실행 중 한 번만 초기화됨)\\n• x += 2로 x 값을 2씩 증가시킴\\n• 증가된 x 값을 반환\\n\\n이제 실행 과정을 정확히 추적해 봅시다:\\n1.첫 번째 반복 (i=0):\\n• main()의 x는 1에서 2로 증가\\n• func()가 호출되고, static x는 0에서 2로 증가하고 2를 반환\\n• sum은 0 + 2 = 2가 됨\\n\\n2.두 번째 반복 (i=1):\\n• main()의 x는 2에서 3으로 증가\\n• func()가 호출되고, static x는 2에서 4로 증가하고 4를 반환\\n• sum은 2 + 4 = 6이 됨\\n3. 세 번째 반복 (i=2):\\n• main()의 x는 3에서 4로 증가\\n• func()가 호출되고, static x는 4에서 6으로 증가하고 6을 반환\\n• sum은 6 + 6 = 12가 됨\\n4. 네 번째 반복 (i=3):\\n• main()의 x는 4에서 5로 증가\\n• func()가 호출되고, static x는 6에서 8로 증가하고 8을 반환\\n• sum은 12 + 8 = 20이 됨\\n\\n반복문 종료 후 sum의 값인 20이 출력됩니다. 따라서 이 코드의 출력값은 20입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_413",
      "title": "다음은 무결성제약조건에 대한 문제이다. 아래 표에서 어떠한 (       ) 무결성을 위반하였는지 작성하시오. ",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "개체",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "이 테이블에서 위반된 무결성은 다음과 같습니다:\\n\\n1. 개체 무결성(Entity Integrity): 기본키(Primary Key)는 NULL 값을 가질 수 없고 유일해야 합니다. 그러나 이 테이블에서는:\\n• StudentID 값이 NULL인 레코드(Eve)가 있습니다.\\n• StudentID 값이 중복된 레코드(Alice와 David 모두 101)가 있습니다.\\n2. 참조 무결성(Referential Integrity): 외래키는 참조하는 테이블의 기본키에 존재하는 값이거나 NULL이어야 합니다. 하지만 이 테이블만으로는 외래키 관계를 확인할 수 없습니다.\\n3. 도메인 무결성(Domain Integrity): 각 속성의 값은 해당 도메인에 속해야 합니다. 현재 보이는 데이터만으로는 도메인 무결성 위반을 확인하기 어렵습니다.\\n4. 사용자 정의 무결성(User-defined Integrity): 비즈니스 규칙에 따른 무결성으로, 현재 테이블만으로는 확인하기 어렵습니다.\\n\\n이 테이블에서 명확하게 위반된 무결성은 개체 무결성(Entity Integrity) 입니다. StudentID가 기본키로 설계되었다면, NULL 값을 가질 수 없고 중복될 수 없어야 하는데, 두 조건 모두 위반되고 있습니다.\\n따라서 정답은 개체무결성입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_414",
      "title": "다음은 URL 구조에 관한 문제이다 . 아래  보기의 순서대로 URL에 해당하는 번호를 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "4 3 1 2 5",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "URL 구조의 각 부분과 정의는 다음과 같습니다:\\n• scheme: 리소스에 접근하는 방법이나 프로토콜\\n• authority: 사용자 정보, 호스트명, 포트 번호\\n• path: 서버 내의 특정 자원을 가리키는 경로\\n• query: 서버에 전달할 추가 데이터\\n• fragment: 특정 문서 내의 위치\\n주어진 URL을 구성 요소별로 분석하면:\\n1. scheme: foo:\\n2. authority: //localhost:8080\\n3. path: /over/there\\n4. query: ?name=ferret\\n5.fragment: #nose\\n따라서 정답은 4-3-1-2-5입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_415",
      "title": "다음은 파이썬에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "45",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "def func(value):\n    if type(value) == type(100):\n        return 100\n    elif type(value) == type(\"\"):\n        return len(value) \n    else:\n        return 20\n \n \na = '100.0'\nb = 100.0\nc = (100, 200)\n \nprint(func(a) + func(b) + func(c))",
      "answer": 1,
      "explanation": {
        "text": "이 코드를 단계별로 분석해 보겠습니다:\\n1. func 함수는 인자 value의 타입에 따라 다른 값을 반환합니다:\\n• value가 정수형(int) 타입이면 100을 반환\\n• value가 문자열(str) 타입이면 문자열의 길이를 반환\\n• 그 외의 타입이면 20을 반환\\n2.변수 정의:\\n• a = '100.0': 문자열 타입\\n• b = 100.0: 부동소수점(float) 타입\\n• c = (100, 200): 튜플(tuple) 타입\\n3. func(a) 호출:\\n• a는 문자열 타입이므로 type(a) == type(\"\")는 참\\n• 따라서 len(a)를 반환, 즉 '100.0'의 길이인 5 반환\\n4. func(b) 호출:\\n• b는 float 타입이므로 type(b) == type(100)와 type(b) == type(\"\") 모두 거짓\\n• 따라서 else 문이 실행되어 20 반환\\n5. func(c) 호출:\\n• c는 튜플 타입이므로 type(c) == type(100)와 type(c) == type(\"\") 모두 거짓\\n• 따라서 else 문이 실행되어 20 반환\\n6. 최종 계산:\\n• func(a) + func(b) + func(c) = 5 + 20 + 20 = 45\\n따라서 이 코드의 출력값은 45입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_416",
      "title": "다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "52",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class Main{\n  public static void main(String[] args){\n    Base a =  new Derivate();\n    Derivate b = new Derivate();\n    \n    System.out.print(a.getX() + a.x + b.getX() + b.x);\n  }\n}\n \n \nclass Base{\n  int x = 3;\n \n  int getX(){\n     return x * 2; \n  }\n}\n \nclass Derivate extends Base{\n  int x = 7;\n  \n  int getX(){\n     return x * 3;\n  }\n}\n",
      "answer": 1,
      "explanation": {
        "text": "1. a.getX():\\n- a의 선언 타입은 Base이지만, 실제 객체는 Derivate입니다.\\n- Java에서 메서드 호출은 실제 객체 타입에 따라 결정됩니다(동적 바인딩).\\n- 따라서 Derivate의 getX() 메서드가 호출됩니다.\\n- Derivate의 getX()는 x * 3을 반환하고, 여기서 x는 Derivate의 x 값인 7입니다.\\n- 결과: 7 * 3 = 21\\n\n\\n\n2. a.x:\\n- 변수 접근은 참조 변수의 선언 타입에 따라 결정됩니다(정적 바인딩).\\n- a의 선언 타입은 Base이므로 Base의 x 값인 3을 사용합니다.\\n- 결과: 3\\n\n\\n\n3. b.getX():\\n- b는 Derivate 타입으로 선언되었고, 실제 객체도 Derivate입니다.\\n- Derivate의 getX() 메서드가 호출됩니다.\\n- 결과: 7 * 3 = 21\\n\n\\n\n4. b.x:\\n- b는 Derivate 타입으로 선언되었으므로 Derivate의 x 값인 7을 사용합니다.\\n- 결과: 7\\n\n\\n\n5. 최종 계산:\\n- a.getX() + a.x + b.getX() + b.x = 21 + 3 + 21 + 7 = 52\\n\n\\n\n• 이 문제는 Java의 상속, 메서드 오버라이딩, 그리고 변수 shadowing(가리기) 개념을 이해하는 것이 중요합니다.\\n• 특히,\\n- 메서드 호출은 객체의 실제 타입에 따라(동적 바인딩),\\n- 변수 접근은 참조 변수의 선언 타입에 따라(정적 바인딩) 결정된다는 점을 명확히 이해해야 합니다.\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_417",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "312",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nstruct Node {\n int value;\n struct Node* next;\n};\n \nvoid func(struct Node* node){\n  while(node != NULL && node->next != NULL){\n     int t = node->value;\n     node->value = node->next->value;\n     node->next->value = t;\n     node = node->next->next;\n  }\n}\n \nint main(){\n  struct Node n1 = {1, NULL};\n  struct Node n2 = {2, NULL};\n  struct Node n3 = {3, NULL};\n  \n  n1.next = &n3;\n  n3.next = &n2;\n \n  func(&n1);  \n \n  struct Node* current = &n1;\n \n  while(current != NULL){\n    printf(\"%d\", current->value);\n    current = current->next;\n }\n \n return 0;\n \n}",
      "answer": 1,
      "explanation": {
        "text": "• 코드를 단계별로 분석해 보겠습니다:\\n\n\\n\n• 세 개의 Node 구조체를 선언하고 초기화합니다:\\n- n1: value는 1, next는 NULL\\n- n2: value는 2, next는 NULL\\n- n3: value는 3, next는 NULL\\n\n\\n\n• 노드들을 연결합니다:\\n- n1.next = &n3: n1 → n3\\n- n3.next = &n2: n1 → n3 → n2\\n\n\\n\n• func(&n1) 함수를 호출합니다. 이 함수는:\\n- 연결 리스트를 순회하면서 인접한 두 노드의 값을 서로 교환합니다.\\n- 교환 후 다음 다음 노드로 이동합니다(node = node->next->next).\\n\n\\n\n• 그 후, 연결 리스트를 순회하며 각 노드의 값을 출력합니다.\\n\n\\n\n• 이제 func 함수의 실행 과정을 자세히 살펴보겠습니다:\\n- 초기 연결 리스트: n1(1) → n3(3) → n2(2)\\n- func(&n1) 호출:\\n\\n  첫 번째 반복:\\n  - node != NULL && node->next != NULL은 참입니다 (n1과 n3 모두 NULL이 아님).\\n  - t = node->value = 1\\n  - node->value = node->next->value = 3 (n1의 값을 3으로 변경)\\n  - node->next->value = t = 1 (n3의 값을 1로 변경)\\n  - node = node->next->next = &n2 (n3의 다음인 n2로 이동)\\n\\n  두 번째 반복:\\n  - node != NULL && node->next != NULL은 거짓입니다 (n2의 다음은 NULL).\\n  - 반복문 종료\\n\n\\n\n• 변경 후 연결 리스트: n1(3) → n3(1) → n2(2)\\n\n\\n\n• main 함수에서 변경된 리스트를 순회하며 값을 출력:\\n- 첫 번째 노드(n1)의 값: 3\\n- 두 번째 노드(n3)의 값: 1\\n- 세 번째 노드(n2)의 값: 2\\n\n\\n\n• 따라서 최종 출력값은 312입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_418",
      "title": "다음은 테스트 커버리지에 대한 문제이다. 아래 내용에 알맞는 답을 보기에서 골라 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 문장  2. 분기  3. 조건",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "1. 테스트를 통해 프로그램의 모든 문장을 최소한 한 번씩 실행했는지를 측정:\\n- 이것은 모든 코드 \"문장\"을 실행하는지 확인하는 것으로, 문장 커버리지(Statement Coverage) 또는 **라인 커버리지(Line Coverage)**를 의미합니다.\\n- 선택지에서는 \"문장\"에 해당합니다.\\n\n\\n\n2. 프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 한 번씩 실행했는지를 측정:\\n- 이것은 조건문(if, switch 등)의 모든 가능한 결과(참/거짓)를 테스트하는 것으로, 분기 커버리지(Branch Coverage) 또는 **결정 커버리지(Decision Coverage)**를 의미합니다.\\n- 선택지에서는 \"분기\"에 해당합니다.\\n\n\\n\n3. 복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정:\\n- 이것은 복합 조건식(예: if(a && b || c))에서 개별 조건(a, b, c)이 각각 참/거짓일 때의 모든 경우를 테스트하는 것으로, **조건 커버리지(Condition Coverage)**를 의미합니다.\\n- 선택지에서는 \"조건\"에 해당합니다.\\n\n\\n\n• 따라서 정답은:\\n- 1. 문장\\n- 2. 분기\\n- 3. 조건",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_419",
      "title": "아래는 UML클래스의 관계에 관한 문제이다. 보기를 보고 알맞는 관계를 선택하여 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 연관  2. 일반화  3. 의존",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• (1) 다이어그램: \"차\"와 \"타이어\", \"바퀴\", \"엔진\" 간의 관계\\n- 이 다이어그램은 \"차\"가 \"타이어\", \"바퀴\", \"엔진\"을 구성요소로 가지는 관계를 보여줍니다.\\n- 이는 한 객체가 다른 객체들을 포함하는 연관(Association) 관계입니다.\\n\n\\n\n• (2) 다이어그램: \"차\"와 \"버스\", \"택시\", \"승용차\" 간의 관계\\n- 이 다이어그램은 \"버스\", \"택시\", \"승용차\"가 \"차\"의 한 종류임을 보여주는 일반화(Generalization) 관계입니다.\\n- 이는 상속 관계로, 하위 클래스가 상위 클래스의 특성을 물려받습니다.\\n\n\\n\n• (3) 다이어그램: \"텔레비전\"과 \"리모콘\" 간의 관계\\n- 이 다이어그램은 점선으로 연결되어 있으며, 두 객체 간의 의존(Dependency) 관계를 나타냅니다.\\n- 의존 관계는 한 클래스가 다른 클래스를 사용하지만 소유하지는 않는 관계입니다.\\n\n\\n\n• 따라서 정답은:\\n- 1. 연관(Association)\\n- 2. 일반화(Generalization)\\n- 3. 의존(Dependency)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_420",
      "title": "다음은 데이터베이스에 관한 문제이다. 아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 외래키  2. 후보키  3. 대체키  4. 슈퍼키",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• (1) **\"다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\"**\\n- 이는 다른 테이블의 기본 키(Primary Key)를 참조하는 키를 의미합니다.\\n- 이러한 특성을 가진 것은 외래키(Foreign Key)입니다.\\n\n\\n\n• (2) **\"테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\"**\\n- 각 행을 유일하게 식별하는 최소한의 속성 집합은 후보키(Candidate Key)의 정의입니다.\\n\n\\n\n• (3) **\"후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\"**\\n- 기본 키로 선정되지 않은 후보 키들을 일컫는 용어는 대체키(Alternate Key)입니다.\\n\n\\n\n• (4) **\"테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합\"**\\n- 이 설명은 각 레코드를 고유하게 식별하는 키를 가리키며, 이는 슈퍼키(Super Key)의 특성입니다.\\n\n\\n\n• 따라서 정답은:\\n- (1) 외래키\\n- (2) 후보키\\n- (3) 대체키\\n- (4) 슈퍼키",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_421",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nvoid func(int** arr, int size){\n  for(int i=0; i<size; i++){\n     *(*arr + i) = (*(*arr+i) + i) % size;\n  }\n}\n \nint main(){\n  int arr[] = {3,1, 4, 1, 5};\n  int* p = arr;\n  int** pp = &p;\n  int num = 6;\n  \n  func(pp, 5);  \n  num = arr[2];\n  printf(\"%d\", num);  \n \n  return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "• 이 코드를 순서대로 따라가 보겠습니다:\\n\n\\n\n• main() 함수에서:\\n- **arr[] 배열을 {3, 1, 4, 1, 5}로 초기화합니다.**\\n- **p는 arr의 주소(배열의 첫 요소를 가리키는 포인터)를 가리킵니다.**\\n- **pp는 p의 주소를 가리키는 이중 포인터입니다.**\\n- **num은 6으로 초기화됩니다.**\\n\n\\n\n• func(pp, 5) 함수를 호출합니다:\\n- **func 함수는 이중 포인터 arr와 크기 size를 매개변수로 받습니다.**\\n- **이 함수 내부에서 arr는 pp의 값, 즉 p의 주소를 가리킵니다.**\\n\n\\n\n• func 함수 내의 반복문을 살펴보겠습니다:\\n- **이 반복문은 i가 0부터 4(size-1)까지 반복합니다.**\\n- **(arr + i)는 (pp + i)와 같고, 이는 p의 주소에서 i만큼 떨어진 위치에 있는 값을 의미합니다.**\\n- **이 값을 해당 값 + i로 바꾸고, size로 나눈 나머지를 저장합니다.**\\n\\n- for(int i=0; i<size; i++){ *(arr + i) = (*(arr+i) + i) % size; }\\n\n\\n\n• 이제 i에 따라 어떻게 변하는지 따라가 보겠습니다:\\n- i=0: (pp + 0) = p = arr의 주소\\n- (arr + 0) = p = arr의 주소\\n- 새 값: (p + 0) % 5 = p % 5\\n- 그러나 여기서 문제가 있습니다. 포인터에 모듈러 연산을 수행하는 것은 의미가 없습니다.\\n- 사실 이 코드는 포인터 연산으로 인해 정의되지 않은 동작(undefined behavior)을 일으킬 가능성이 높습니다.\\n\n\\n\n• 하지만 문제의 의도를 파악해보면, 아마도 (arr + i)는 (*arr + i)의 의미로 사용되었을 것입니다.\\n\n\\n\n• 따라서 배열 값의 변화를 추적하면:\\n- i=0: arr[0] = (3 + 0) % 5 = 3\\n- i=1: arr[1] = (1 + 1) % 5 = 2\\n- i=2: arr[2] = (4 + 2) % 5 = 1\\n- i=3: arr[3] = (1 + 3) % 5 = 4\\n- i=4: arr[4] = (5 + 4) % 5 = 4\\n\n\\n\n• 함수 호출 후 배열은 {3, 2, 1, 4, 4}가 됩니다.\\n- num = arr[2]에서 num은 배열의 세 번째 요소인 1이 됩니다.\\n- 따라서 printf(\"%d\", num)의 출력값은 1입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_422",
      "title": "다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "101",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "public class ExceptionHandling {\n  public static void main(String[] args) {\n      int sum = 0;\n      try {\n          func();\n      } catch (NullPointerException e) {\n          sum = sum + 1;\n      } catch (Exception e) {\n          sum = sum + 10;\n      } finally {\n          sum = sum + 100;\n      }\n      System.out.print(sum);\n  }\n \n  static void func() throws Exception {\n      throw new NullPointerException(); \n  }\n}\n",
      "answer": 1,
      "explanation": {
        "text": "• 코드의 실행 과정을 단계별로 추적해 보겠습니다:\\n\n\\n\n• main 메서드에서 **sum 변수를 0으로 초기화합니다.**\\n\n\\n\n• try 블록에서 **func() 메서드를 호출합니다.**\\n\n\\n\n• func() 메서드는 **NullPointerException을 발생시킵니다.**\\n\n\\n\n• 발생한 예외는 첫 번째 catch 블록에서 처리됩니다:\\n- **여기서 sum은 0에서 1로 증가합니다.**\\n\n\\n\n• 예외가 첫 번째 catch 블록에서 처리되었으므로, **두 번째 catch 블록은 실행되지 않습니다.**\\n\n\\n\n• 그 후 finally 블록이 실행됩니다:\\n- **여기서 sum은 1에서 101로 증가합니다.**\\n\n\\n\n• 마지막으로 System.out.print(sum)에서 **sum의 값인 101을 출력합니다.**\\n\n\\n\n• 따라서 이 코드의 출력값은 **101**입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_423",
      "title": "다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "B0",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Main {\n \n  public static class Collection<T>{\n    T value;\n \n    public Collection(T t){\n        value = t;\n    }\n \n    public void print(){\n       new Printer().print(value);\n    }\n \n   class Printer{\n      void print(Integer a){\n        System.out.print(\"A\" + a);\n      }\n      void print(Object a){\n        System.out.print(\"B\" + a);\n      } \n      void print(Number a){\n        System.out.print(\"C\" + a);\n      }\n   }\n }\n \n  public static void main(String[] args) {\n      new Collection<>(0).print();\n  }\n  \n}",
      "answer": 1,
      "explanation": {
        "text": "• 이 코드의 실행 과정을 단계별로 분석해 보겠습니다:\\n\n\\n\n• main 메서드에서 **new Collection<>(0).print()를 호출합니다.**\\n\n\\n\n• Collection 클래스의 인스턴스를 생성하며, **제네릭 타입 파라미터 T에 대해 타입 추론이 일어납니다.**\\n- 생성자에 0이 전달되는데, 이는 **Integer 타입으로 자동 박싱(auto-boxing)됩니다.**\\n- 따라서 **Collection<Integer> 인스턴스가 생성되고 value에는 Integer 타입의 0이 저장됩니다.**\\n\n\\n\n• 생성된 Collection 인스턴스의 **print() 메서드가 호출됩니다.**\\n- 이 메서드 내에서 **new Printer().print(value)가 호출됩니다.**\\n- value는 **Integer 타입의 0입니다.**\\n\n\\n\n• Printer 클래스의 print 메서드 중 **어떤 것이 호출될지 결정해야 합니다:**\\n- print(Integer a) - **정확히 Integer 타입과 일치**\\n- print(Number a) - **Integer는 Number의 하위 클래스이므로 호환됨**\\n- print(Object a) - **모든 클래스는 Object의 하위 클래스이므로 호환됨**\\n\n\\n\n• Java의 메서드 오버로딩 해결 규칙에 따르면, **가장 구체적인(specific) 타입과 일치하는 메서드가 선택됩니다.**\\n- 이 경우 **Integer 타입과 정확히 일치하는 print(Integer a) 메서드가 호출됩니다.**\\n\n\\n\n• print(Integer a) 메서드는 **System.out.print(\"A\" + a)를 실행합니다.**\\n- a는 0이므로 **\"A0\"가 출력될 것입니다.**\\n\n\\n\n• 하지만 문제의 답은 \"B0\"로 주어져 있습니다.\\n- 코드를 다시 검토해보니, **여기서는 타입 추론과 관련된 문제가 있을 수 있습니다.**\\n- **new Collection<>(0)에서 다이아몬드 연산자(<>)를 사용하고 있지만, 명시적인 타입 파라미터가 없습니다.**\\n- 이런 경우 **Java 컴파일러가 Collection<Object> 또는 다른 타입으로 추론할 가능성이 있습니다.**\\n- 만약 컴파일러가 Collection<Object>로 타입을 추론한다면, **value는 Object 타입이 되고, print 메서드 호출 시 print(Object a)가 선택되어 \"B0\"가 출력될 것입니다.**\\n\n\\n\n• 따라서 정답은 **B0**입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_425",
      "title": "시스템의 성능을 향상시키고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위는?",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "반정규화 (비정규화, 역정규화)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**데이터베이스 반정규화(Denormalization)** : 데이터베이스 성능 향상 등을 위해 정규화된 데이터를 의도적으로 정규형을 위배한 데이터 구조로 만드는 행위",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_426",
      "title": "다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "NNN",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        \n        check(a, b);\n        \n        check(a, c);\n        \n        check(b, c);\n    }\n \n    public static void check(int[] a, int[] b) {\n \n        if (a == b) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"N\");\n        }\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "**1. check(a, b):**\\na와 b는 같은 내용 {1, 2, 3, 4}를 가지고 있지만, 서로 다른 배열 객체입니다. == 연산자는 객체의 참조를 비교하므로, 두 배열이 같은 객체를 참조하는지 확인합니다.a와 b는 별도로 생성된 배열이므로 서로 다른 메모리 주소를 가집니다. 따라서 a == b는 false가 되어 \"N\"이 출력됩니다.\\n\\n**2. check(a, c):**\\na와 c는 내용도 다르고 (a는 4개 요소, c는 3개 요소) 서로 다른 배열 객체입니다. 마찬가지로 == 연산자는 참조를 비교하므로 false가 되어 \"N\"이 출력됩니다.\\n\\n**3. check(b, c):**\\nb와 c 역시 서로 다른 배열 객체입니다. 내용과 크기가 다르지만, == 연산자는 이를 고려하지 않고 단순히 참조만 비교합니다. 따라서 false가 되어 \"N\"이 출력됩니다\\n\\n만약 배열의 내용을 비교하고 싶다면, Arrays.equals(a, b) 메서드를 사용해야 합니다. 이 메서드는 배열의 길이와 각 요소를 비교합니다. 또는 배열의 내용을 직접 순회하면서 비교하는 로직을 구현할 수도 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_427",
      "title": "다음은 SQL에 관한 문제이다. 아래 SQL 구문의 빈칸을 작성하시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "① VALUES, ② SELECT, ③ FROM, ④ SET",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• 정답: ① VALUES 설명: INSERT INTO 문에서 새로운 레코드의 값을 지정할 때 VALUES 키워드를 사용합니다.\\n• 정답: ② SELECT 설명: 다른 테이블에서 데이터를 선택하여 삽입할 때 SELECT 문을 사용합니다.\\n• 정답: ③ FROM 설명: SELECT 문에서 데이터를 조회할 테이블을 지정할 때 FROM 키워드를 사용합니다.\\n• 정답: ④ SET 설명: UPDATE 문에서 변경할 열과 값을 지정할 때 SET 키워드를 사용합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_428",
      "title": "다음은 프로토콜에 대한 내용이다. 아래 내용을 읽고 알맞는 답을 작성하시오.",
      "subject": "응용SW기초 기술 활용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "IPSec",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• 정의: IPsec은 Internet Protocol Security의 약자로, IP 통신에 보안을 제공하는 프로토콜 스위트입니다.\\n• 기능: IP 패킷 레벨에서 암호화와 인증을 제공합니다. 데이터의 기밀성, 무결성, 인증을 보장합니다.\\n• 사용 계층: 네트워크 계층(Network Layer)에서 동작합니다.\\n• 주요 용도: VPN(Virtual Private Network) 구현, 안전한 원격 접속 제공, 기업의 사설 네트워크 보안\\n• 주요 프로토콜: AH (Authentication Header): 데이터 무결성과 인증을 제공합니다. ESP (Encapsulating Security Payload): 암호화를 통한 기밀성과 선택적 인증을 제공합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_429",
      "title": "다음은 Python에 대한 문제이다. 아래 코드를 읽고 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ab3ca2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "def fnCalculation(x, y):\n    result = 0\n    for i in range(len(x)):\n        temp = x[i:i+len(y)]\n        if temp == y:\n            result += 1\n    return result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\n\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\n\nprint(out)",
      "answer": 1,
      "explanation": {
        "text": "**• fnCalculation 함수:** 이 함수는 주어진 문자열 x 내에서 부분 문자열 y가 몇 번 나타나는지 계산합니다. 문자열 x를 처음부터 끝까지 순회하면서, 각 위치에서 y 길이만큼의 부분 문자열을 추출하여 y와 비교합니다. 일치하는 경우마다 result를 1씩 증가시킵니다.\\n\\n**• 메인 문자열과 검색할 부분 문자열:**\\n a = \"abdcabcabca\": 검색 대상이 되는 메인 문자열입니다.\\n p1 = \"ab\", p2 = \"ca\": 검색할 두 개의 부분 문자열입니다.\\n\\n\n**결과 계산:**\\n fnCalculation(a,p1): \"ab\"가 \"abdcabcabca\" 내에서 3번 나타납니다 (인덱스 0, 4, 7에서 시작). 따라서 이 호출의 결과는 3입니다.\\n fnCalculation(a,p2): \"ca\"가 \"abdcabcabca\" 내에서 2번 나타납니다 (인덱스 5, 9에서 시작). 따라서 이 호출의 결과는 2입니다.\\n\\n\n**최종 출력 문자열 생성:**\\n f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\": 이 f-string은 \"ab\", 첫 번째 함수 호출의 결과 (3), \"ca\", 두 번째 함수 호출의 결과 (2)를 연결합니다. 따라서 최종 결과 문자열은 \"ab3ca2\"가 됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_430",
      "title": "아래 설명하는 내용을 확인하여 알맞는 알고리즘을 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "AES",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "AES는 Advanced Encryption Standard의 약자로, 고급 암호화 표준을 의미합니다.\\n**개발 배경:**\\n• 1997년 NIST(미국 국립표준기술연구소)에서 DES(Data Encryption Standard)를 대체하기 위해 공모를 시작했습니다.\\n• 2000년에 Rijndael 알고리즘이 AES로 선정되었습니다.\\n\\n**주요 특징:**\\n• 대칭키 블록 암호 알고리즘입니다.\\n• 키 크기: 128비트, 192비트, 256비트 중 선택 가능합니다.\\n• 블록 크기: 고정 128비트입니다.\\n• 라운드 수: 키 크기에 따라 10, 12, 14라운드로 구성됩니다.\\n\\n**장점:**\\n• 높은 보안성: 현재까지 실용적인 공격 방법이 알려지지 않았습니다.\\n• 효율성: 하드웨어와 소프트웨어에서 모두 효율적으로 구현 가능합니다.\\n• 속도: DES보다 빠른 암호화 및 복호화 속도를 제공합니다.\\n• 유연성: 다양한 키 크기를 지원하여 보안 수준을 선택할 수 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_431",
      "title": "패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "가상회선, 데이터그램",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**① 연결형 교환 방식: 가상회선 (Virtual Circuit)**\\n1. 정의: 데이터 전송 전에 송신자와 수신자 간에 논리적 연결을 먼저 설정하는 방식입니다.\\n2. 작동 과정:\\n• 연결 설정: 데이터 전송 전 경로를 설정합니다.\\n• 데이터 전송: 설정된 경로를 따라 패킷들이 순서대로 전송됩니다.\\n• 연결 해제: 데이터 전송 완료 후 연결을 종료합니다.\\n3. 장점:\\n• 패킷의 순서가 보장됩니다.\\n• 흐름 제어와 오류 제어가 용이합니다.\\n4. 단점: • 초기 연결 설정에 시간이 소요됩니다.\\n• 연결 유지에 추가적인 오버헤드가 발생합니다.\\n**② 비연결형 교환 방식: 데이터그램 (Datagram)**\\n1.정의: 각 패킷이 독립적으로 처리되며, 사전 연결 설정 없이 데이터를 전송하는 방식입니다.\\n2. 작동 과정: • 연결 설정 없음: 데이터 전송 전 별도의 경로 설정 과정이 없습니다.\\n• 개별 패킷 라우팅: 각 패킷은 목적지 주소를 포함하여 독립적으로 라우팅됩니다.\\n3. 장점:\\n• 연결 설정 오버헤드가 없어 빠른 전송 시작이 가능합니다.\\n• 네트워크 자원을 효율적으로 사용할 수 있습니다.\\n4. 단점: • 패킷의 순서가 보장되지 않습니다.\\n• 패킷 손실 가능성이 있습니다.\\n이 두 방식은 각각 다른 상황과 요구사항에 적합하며, 네트워크 통신에서 중요한 역할을 합니다. 가상회선은 **신뢰성**이 중요한 경우에, 데이터그램은 **빠른 전송**이 필요한 경우에 주로 사용됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_432",
      "title": "아래 내용을 확인하고 보기에서 알맞는 답을 고르시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "순차적",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**기능적(Functional) 응집도:**\\n• 키워드: 단일 기능, 높은 응집도\\n• 설명: 모듈이 단일 잘 정의된 기능을 수행\\n\\n**순차적(Sequential) 응집도:**\\n• 키워드: 순서, 출력-입력 연결\\n• 설명: 한 요소의 출력이 다음 요소의 입력으로 사용되는 순차적 실행\\n\\n**통신적(Communication) 응집도:**\\n• 키워드: 공통 데이터, 데이터 중심\\n• 설명: 같은 입출력 데이터를 사용하는 요소들로 구성\\n\\n**절차적(Procedural) 응집도:**\\n• 키워드: 프로세스, 관련 활동\\n• 설명: 특정 프로세스의 여러 관련 단계를 수행하는 요소들로 구성\\n\\n**시간적(Temporal) 응집도:**• 키워드: 동시 실행, 특정 시점\\n• 설명: 특정 시점에 함께 실행되어야 하는 기능들로 구성\\n\\n**논리적(Logical) 응집도:**• 키워드: 유사 기능, 선택적 실행\\n• 설명: 유사한 기능을 수행하지만 서로 관련이 없는 요소들로 구성\\n\\n**우연적(Coincidental) 응집도:**\\n• 키워드: 무관한 기능, 낮은 응집도\\n• 설명: 서로 관련 없는 기능들이 우연히 같은 모듈에 묶인 경우\\n이 응집도 유형들은 높은 응집도(기능적)에서 낮은 응집도(우연적) 순으로 나열되어 있습니다. 일반적으로 높은 응집도를 가진 모듈 설계가 바람직합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_433",
      "title": "아래는 디자인 패턴에 관한 설명이다. 아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Iterator",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**생성 패턴:**\\n1.Singleton:\\n• 키워드: 단일 인스턴스, 전역 접근점\\n• 설명: 클래스의 인스턴스가 하나만 생성되도록 보장\\n2. Factory Method:\\n• 키워드: 객체 생성 위임, 서브클래스\\n• 설명: 객체 생성을 서브클래스에 위임하여 유연성 제공\\n3. Abstract Factory:\\n• 키워드: 관련 객체군, 인터페이스\\n• 설명: 관련된 객체들의 family를 생성하기 위한 인터페이스 제공\\n\\n**구조 패턴:**\\n1. Adapter:\\n• 키워드: 인터페이스 변환, 호환성\\n• 설명: 호환되지 않는 인터페이스들을 함께 동작하도록 변환\\n2.Bridge:\\n• 키워드: 구현-추상화 분리, 독립적 변화\\n• 설명: 추상화와 구현을 분리하여 독립적으로 변화 가능하게 함\\n3. Composite:\\n• 키워드: 트리 구조, 부분-전체 계층\\n• 설명: 객체들의 트리 구조를 구성하여 부분-전체 계층을 표현\\n\\n**행위 패턴:**\\n1. Iterator:\\n• 키워드: 순차적 접근, 내부 구조 은닉\\n• 설명: 컬렉션의 내부 구조를 노출하지 않고 순차적 접근 제공\\n2. Visitor:\\n• 키워드: 동작 분리, 새로운 연산 추가\\n• 설명: 객체 구조와 동작을 분리하여 새로운 동작 쉽게 추가\\n3.  Observer:\\n• 키워드: 상태 변화 통지, 일대다 의존성\\n• 설명: 객체 상태 변화를 다른 객체들에게 자동으로 통지\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_434",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "21",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    \n    int* parr[2] = {arr[1], arr[2]};\n    \n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    \n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\\n• 3x3 2차원 배열을 초기화합니다.\\n• arr[0] = {1, 2, 3}\\n• arr[1] = {4, 5, 6}\\n• arr[2] = {7, 8, 9}\\n\\nint* parr[2] = {arr[1], arr[2]};\\n• 포인터 배열 parr을 생성하고 초기화합니다.\\n• parr[0]은 arr[1]의 주소를 가리킵니다 (즉, {4, 5, 6}의 시작 주소)\\n• parr[1]은 arr[2]의 주소를 가리킵니다 (즉, {7, 8, 9}의 시작 주소)\\n\\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr); 이 부분을 세 부분으로 나누어 계산합니다:\\n\\na. parr[1][1]:\\nparr[1]은 arr[2]를 가리키므로, parr[1][1]은 arr[2][1]과 같습니다.\\n따라서 parr[1][1]의 값은 8입니다.\\n\\nb. *(parr[1]+2):\\nparr[1]은 arr[2]의 시작 주소입니다.\\nparr[1]+2는 arr[2]의 세 번째 요소를 가리킵니다.\\n따라서 *(parr[1]+2)의 값은 9입니다.\\n\\nc. **parr:\\n*parr은 parr[0]과 같고, 이는 arr[1]의 주소입니다.\\n**parr은 arr[1]의 첫 번째 요소를 가리킵니다.\\n따라서 **parr의 값은 4입니다.\\n\\n**최종 계산: 8 + 9 + 4 = 21**",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_435",
      "title": "다음은 Java 언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "25, 20",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\n\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\n\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}",
      "answer": 1,
      "explanation": {
        "text": "int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\\n• 1부터 9까지의 정수를 포함하는 배열 a를 초기화합니다. \\n\\nODDNumber OE = new ODDNumber();\\n• ODDNumber 클래스의 인스턴스 OE를 생성합니다.\\n\\nSystem.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\\n• OE.sum(a, true)를 호출하여 홀수의 합을 계산합니다:\\n• true를 전달하므로 홀수만 더합니다.\\n• 1 + 3 + 5 + 7 + 9 = 25\\n\\nOE.sum(a, false)를 호출하여 짝수의 합을 계산합니다:\\n• false를 전달하므로 짝수만 더합니다.\\n• 2 + 4 + 6 + 8 = 20\\n\\nsum 메소드의 동작:\\n• 배열 a를 순회하면서 각 요소를 확인합니다.\\n• odd가 true일 때:\\na[i] % 2 != 0 조건을 만족하는 홀수만 result에 더합니다.\\n• odd가 false일 때:\\na[i] % 2 == 0 조건을 만족하는 짝수만 result에 더합니다.\\n\\n최종 출력:\\n• 홀수의 합 25와 짝수의 합 20이 콤마로 구분되어 출력됩니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_436",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "10",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n#include <string.h>\n\nvoid sumFn(char* d, char* s) {\n    int sum = 0;\n\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0';\n}\n\nint main() {\n    char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result = 0;\n    sumFn(str2, str1);\n\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    \n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "1. char* str1 = \"first\";\\n• \"first\"라는 문자열을 가리키는 포인터 str1을 선언합니다.\\n\\n2. char str2[50] = \"teststring\";\\n• 50바이트 크기의 문자 배열 str2를 선언하고 \"teststring\"으로 초기화합니다.\\n\\n3. sumFn(str2, str1);\\n• sumFn 함수를 호출하여 str1의 내용을 str2에 복사합니다.\\n• 복사 후 str2는 \"first\"가 됩니다. (나머지는 null 문자로 채워집니다)\\n\\n4. for 루프에서의 계산:\\n• str2의 각 문자에 대해 그 인덱스를 result에 더합니다.\\n• str2는 이제 \"first\"이므로:\\n'f'의 인덱스: 0\\n'i'의 인덱스: 1\\n'r'의 인덱스: 2\\n's'의 인덱스: 3\\n't'의 인덱스: 4\\n따라서 result = 0 + 1 + 2 + 3 + 4 = 10\\n\\n5. printf(\"%d\", result);\\n최종적으로 계산된 result 값인 10을 출력합니다.\\n\\n**이 코드의 주요 포인트는 다음과 같습니다:**\\n• sumFn 함수는 실제로 문자열을 더하는 것이 아니라 복사하는 기능을 합니다.\\n• 원래 str2의 내용은 완전히 덮어써집니다.\\n• 최종 결과는 복사된 문자열 \"first\"의 각 문자 인덱스의 합입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_437",
      "title": "아래는 소프트웨어 설계에 대한 내용이다. 내용을 읽고 괄호안에 알맞는 답을 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Control",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "Control Coupling: 한 모듈이 다른 모듈의 수행 경로에 영향을 미치는 제어 정보를 인자로 넘겨서, 수행 로직을 제어하는 방식의 결합도를 말합니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_438",
      "title": "다음은 Java에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "dcba",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n\n        char c = str.charAt(index);\n\n        String result = calculFn(str, index-1, seen);\n\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "• 입력 문자열 \"abacabcd\"에 대해 함수가 호출됩니다.\\n• 재귀 호출이 문자열의 끝에서 시작하여 앞으로 이동합니다:\\n\\nindex 7 ('d'): 처음 본 문자, 결과에 추가 -> \"d\"\\nindex 6 ('c'): 처음 본 문자, 결과에 추가 -> \"cd\"\\nindex 5 ('b'): 처음 본 문자, 결과에 추가 -> \"bcd\"\\nindex 4 ('a'): 이미 본 문자, 무시 -> \"bcd\"\\nindex 3 ('c'): 이미 본 문자, 무시 -> \"bcd\"\\nindex 2 ('a'): 이미 본 문자, 무시 -> \"bcd\"\\nindex 1 ('b'): 이미 본 문자, 무시 -> \"bcd\"\\nindex 0 ('a'): 이미 본 문자, 무시 -> \"bcd\"\\n\\n최종 결과는 **\"dcba\"**입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_439",
      "title": "다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "-13",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\n\nint main() {\n    int a = 11;\n    int b = 19;\n    \n    swap(a, b);\n    \n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    \n    printf(\"%d\", a-b);\n}",
      "answer": 1,
      "explanation": {
        "text": "변수 초기화:\\n• a는 11로 초기화됩니다.\\n• b는 19로 초기화됩니다.\\n\\nswap(a, b) 함수 호출:\\n• 이 함수는 값에 의한 전달(pass by value)을 사용합니다.\\n• 함수 내에서 a와 b의 값이 교환되지만, 이는 함수의 지역 변수에만 영향을 줍니다.\\n• 함수 호출이 끝나면 main 함수의 a와 b는 변경되지 않은 상태로 남습니다.\\n• 따라서 a는 여전히 11, b는 여전히 19입니다.\\n\\nswitch 문:\\n• a의 값은 11이므로 case 11:부터 실행이 시작됩니다.\\n• case 11: 에서 b += 2가 실행되어 b는 21이 됩니다.\\n• case 11: 다음에 break가 없으므로 실행이 계속되어 default: 케이스로 넘어갑니다.\\n• default: 에서 b += 3이 실행되어 b는 24가 됩니다.\\n• break를 만나 switch 문이 종료됩니다.\\n\\n최종 계산 및 출력:\\n• a는 11로 유지되고 있습니다.\\n• b는 24가 되었습니다.\\n• a - b는 11 - 24 = -13 입니다.\\n• 따라서 -13이 출력됩니다.\\n\\n**swap 함수에 포인터를 주었다면 값이 바뀌었지만 사용을 하지 않았으므로 지역변수에서만 사용이 되고 실제로 변경이 되지 않습니다.**",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_440",
      "title": "다음은 C언어의 구조체에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "20",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n\nstruct node {\n    int n1;\n    struct node *n2;\n};\n\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n\n    struct node *head = &a;\n    \n    a.n2 = &b;\n    b.n2 = &c;\n\n    printf(\"%d\\n\", head->n2->n1);\n\n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "1. 구조체 정의:\\n• node 구조체는 정수 n1과 다음 노드를 가리키는 포인터 n2로 구성됩니다.\\n\\n2. 노드 생성 및 초기화:\\n\n• a, b, c 세 개의 node 구조체 변수를 생성합니다.\\n• 각각 10, 20, 30의 값으로 n1을 초기화하고, n2는 NULL로 초기화합니다.\\n\\n3. 연결 리스트 구성:\\n• head 포인터를 a 노드의 주소로 초기화합니다. 이는 리스트의 시작점이 됩니다.\\n• a.n2 = &b;로 a 노드의 n2가 b 노드를 가리키게 합니다.\\n• b.n2 = &c;로 b 노드의 n2가 c 노드를 가리키게 합니다.\\n\\n4. 데이터 접근 및 출력:\\n• head->n2->n1을 출력합니다. 이는 다음과 같이 해석됩니다.\\n• head는 a 노드를 가리킵니다.\\n• head->n2는 a 노드의 n2, 즉 b 노드를 가리킵니다.\\n• head->n2->n1은 b 노드의 n1 값, 즉 20을 의미합니다.\\n\\n**따라서, 이 코드의 출력 결과는 20입니다.** 이 코드는 간단한 연결 리스트의 구조를 보여줍니다.\\n• a → b → c → NULL\\n각 노드는 데이터(n1)와 다음 노드를 가리키는 포인터(n2)를 가지고 있으며, 이를 통해 노드들이 서로 연결되어 있습니다. 이러한 구조는 데이터의 동적인 추가와 삭제가 용이한 연결 리스트의 기본 개념을 잘 나타내고 있습니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_441",
      "title": "다음은 Java에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "S",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "문자열 초기화: \\nstr 변수에 \"ITISTESTSTRING\" 문자열이 할당됩니다.\\n\\n문자열 분할:\\nstr.split(\"T\")는 \"T\"를 구분자로 사용하여 문자열을 분할합니다.\\n이 분할 결과는 다음과 같습니다: result[0] = \"I\" result[1] = \"IS\" result[2] = \"ES\" result[3] = \"S\" result[4] = \"RING\"\\n\\n결과 출력:\nSystem.out.print(result[3]);는 분할된 결과의 네 번째 요소(인덱스 3)를 출력합니다.\\n\\n이는 \"S\"입니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_442",
      "title": "다음 라우터 A에서 라우터 F까지 경로를 설정하기 위해 RIP 방식을 사용한다고 할 때, 라우터가 지나가는 경로를 순서대로 쓰시오.(단, 간선 위의 숫자는 라우터 간의 거리를 의미한다.)",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "A ➝ D ➝ C ➝ F",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜 중 하나로, 각 라우터가 이웃 라우터에게 주기적으로 자신의 라우팅 테이블을 전송하여 경로를 학습합니다. RIP는 경로를 계산할 때 홉 수(패킷이 라우터를 통과하는 횟수)를 기준으로 가장 짧은 경로를 선택하며, 최대 홉 수는 15로 제한됩니다. 이때 홉 수가 16 이상이면 해당 경로는 도달할 수 없는 것으로 간주됩니다. \\n\\nRIP (Routing Information Protocol) 방식:\nRIP에서는 홉 수만을 고려하여 경로를 선택합니다.\\n\\nA → F:\\n• A → D → C → F (총 3 홉, 가장 짧음)\\n• A → D → C → E → F (총 4 홉)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_443",
      "title": "다음 테이블에서 카디널리티(Cardinality)와 디그리(Degree)를 구하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "① 카디널리티(Cardinality) : 5\n② 디그리(Degree) : 4",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "1. 튜플(Tuple)\\n• 릴레이션을 구성하는 각 행(row)을 의미\\n• 속성 값의 모임으로 구성\\n• 파일 구조에서 레코드\\n• 튜플의 수 = 카디날리티(Cardinality)\\n\\n2.속성(Attribute)\\n• 릴레이션을 구성하는 각 열\\n• 데이터베이스를 구성하는 가장 작은 논리적 단위\\n• 파일 구조의 데이터 필드\\n• 속성의 수 = 디그리(Degree)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_444",
      "title": "다음 Java 코드를 실행했을 때 출력 결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "4",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Connection {\n \n    private static Connection _inst = null;\n    private int count = 0;\n    \n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    \n    public void count() {\n         count++; \n    }\n    \n    public int getCount() {\n         return count; \n    }\n}\n \n \npublic class main {  \n \n    public static void main(String[] args) {\n \n        Connection conn1 = Connection.get();\n        conn1.count();\n \n        Connection conn2 = Connection.get();\n        conn2.count();\n \n        Connection conn3 = Connection.get();\n        conn3.count();\n        \n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n \n}",
      "answer": 1,
      "explanation": {
        "text": "• Connection 클래스에는 **static 변수 _inst가 있습니다.**\\n- 이 변수는 **Connection 클래스의 모든 인스턴스가 공유하는 변수입니다.**\\n- **_inst = null은 Connection 객체가 생성되지 않은 상태를 의미합니다.**\\n\n\\n\n• Connection conn1 = Connection.get();\\n- **get() 호출 → _inst == null이므로 새로운 Connection 객체 생성**\\n- **conn1은 해당 객체를 참조**\\n\n\\n\n• conn1.count();\\n- **count 값 증가 → count = 1**\\n\n\\n\n• Connection conn2 = Connection.get();\\n- **get() 호출 → 기존 _inst 객체 반환**\\n- **conn2도 conn1과 같은 객체를 참조**\\n\n\\n\n• conn2.count();\\n- **count 값 증가 → count = 2**\\n\n\\n\n• Connection conn3 = Connection.get();\\n- **get() 호출 → 기존 _inst 객체 반환**\\n- **conn3도 동일한 Connection 객체를 참조**\\n\n\\n\n• conn3.count();\\n- **count 값 증가 → count = 3**\\n\n\\n\n• conn1.count();\\n- **count 값 증가 → count = 4**\\n\n\\n\n• System.out.print(conn1.getCount());\\n- **getCount() 호출 → count = 4 반환**\\n- **결과: 4 출력**\\n\n\\n\n• 모든 Connection 객체가 **동일한 인스턴스를 공유하므로 count 변수는 누적됩니다.**\\n- 따라서 최종 출력값은 **4**가 됩니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_445",
      "title": "다음 C 코드의 실행 결과를 구하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "151",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n \nint main() {\n    int v1 = 0, v2 = 35, v3 = 29;\n    \n    if(v1 > v2 ? v2 : v1) {\n        v2 = v2 << 2;\n    }else{\n        v3 = v3 << 2;\n    }\n    \n    printf(\"%d\", v2+v3);\n}",
      "answer": 1,
      "explanation": {
        "text": "1. 삼항 연산자\\n- **v1 > v2는 0 > 35이므로 거짓(false)**\\n- **삼항 연산자는 거짓일 때 값을 선택 → v1 = 0이 선택됨**\\n- **따라서 if(0)이 되어, 조건문은 false**\\n- **따라서 else 블록이 실행됩니다.**\n\\n\n2. else 블록 실행\\n- **v3 = 29**\\n- 방법1) **29 << 2 → 29 * 2^2 = 29 * 4 = 116**\\n- 방법2) **29 → 00011101 (2진수)**\\n- **00011101 << 2 → 01110100 (2진수)**\\n- **왼쪽으로 2칸 이동하면서 오른쪽에 0이 채워짐**\\n- **즉, 00011101 (29) → 01110100 (10진수: 116)**\\n- 따라서 v3 = 116입니다.\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_446",
      "title": "다음 보기에서 응집도가 높은 순으로 나열하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ㄱ, ㄴ, ㄹ, ㄷ",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "응집도(Cohesion)란 모듈 내부 요소들이 서로 관련된 정도를 의미하며, 높을수록 좋은 설계입니다.\\n\n\\n\n• 기능적 응집도 (Functional Cohesion) [가장 강함]\n• 순차적 응집도 (Sequential Cohesion)\\n\n• 통신적(교환적) 응집도 (Communication Cohesion)\\n\n• 절차적 응집도 (Procedural Cohesion)\\n\n• 시간적 응집도 (Temporal Cohesion)\\n\n• 논리적 응집도 (Logical Cohesion)\\n\n• 우연적 응집도 (Coincidental Cohesion) [가장 약함]",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_447",
      "title": "다음 C 코드의 실행 결과를 구하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "GECA",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n    char str[] = \"ABCDEFGH\";\n    char *fir_str;\n    char *end_str;\n    fir_str = &str[0];\n    end_str = &str[strlen(str)-1];    \n  \n    while(fir_str < end_str){\n        char temp = *fir_str;\n        *fir_str = *end_str;\n        *end_str = temp;\n        fir_str++;\n        end_str--;\n    }\n\n    for(int i=1; i<strlen(str); i+=2){\n        printf(\"%c\",str[i]);\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "• 1. 문자열 선언 및 포인터 변수 초기화\\n\n\\n\n- **char str[] = \"ABCDEFGH\";**\\n- str 배열에 문자열 \"ABCDEFGH\"를 저장\\n- **str[0] = 'A', str[1] = 'B', ..., str[7] = 'H'**\\n\n- **char *fir_str, *end_str;**\\n- 문자열의 첫 번째 문자와 마지막 문자를 가리킬 포인터 변수 선언\\n\n- **fir_str → str[0]을 가리킴 ('A')**\\n- **end_str → str[strlen(str)-1], 즉 str[7]을 가리킴 ('H')**\\n- **strlen(str) → 문자열 \"ABCDEFGH\"의 길이 8을 반환**\\n- **str[7] = 'H'이므로 end_str = &str[7];**\\n\n\\n\n• [ 현재 상태 표 ]\\n- fir_str = &str[0] → fir_str은 0x1000 (문자 'A'의 주소)를 가리킴\\n- end_str = &str[strlen(str)-1] → end_str은 0x1007 (문자 'H'의 주소)를 가리킴\\n\n\\n\n• 2. 문자열 뒤집기\\n\n\\n\n- **while(fir_str < end_str){**\\n- fir_str < end_str 조건이 참일 동안 해당 while문이 반복됩니다.\\n- fir_str과 end_str는 각각 str 배열의 주소를 가리키고 있습니다.\\n- fir_str < end_str는 fir_str이 가리키는 주소가 end_str이 가리키는 주소보다 작은지를 확인하는 것입니다.\\n- 메모리에서는 주소가 순차적으로 증가하므로, fir_str이 end_str보다 작은 주소를 가리키고 있다는 의미는 fir_str이 end_str보다 왼쪽에 있다는 것입니다.\\n\n- **char temp = *fir_str;**\\n- *fir_str: fir_str이 가리키고 있는 주소의 값을 가져옵니다. 처음에는 fir_str이 str[0]을 가리키고 있으므로 *fir_str은 'A'입니다.\\n- temp: fir_str이 가리키는 값을 임시로 저장할 변수입니다. *fir_str에서 가져온 값을 temp에 저장하여, 이후에 값을 교환할 때 사용할 수 있도록 합니다.\\n\n- **\\*fir_str = *end_str;**\\n- end_str이 str[7]을 가리키고 있으므로 *end_str은 'H'입니다.\\n- fir_str이 가리키는 위치에 end_str이 가리키는 값을 저장하는 동작입니다. fir_str이 가리키는 'A' 자리에 'H'를 넣습니다.\\n\n- **\\*end_str = temp;**\\n- temp에는 fir_str이 가리켰던 값이 저장되어 있습니다. *end_str에 그 값을 저장합니다.\\n- 즉, end_str이 가리키고 있던 'H' 자리에 fir_str이 가리키고 있던 값인 'A'를 저장합니다.\\n\n- **fir_str++;**\\n- fir_str 포인터를 오른쪽으로 한 칸 이동시킵니다.\\n- 처음에는 fir_str이 str[0]을 가리키고 있기 때문에, 한 번 실행하면 fir_str은 str[1]을 가리키게 됩니다.\\n\n- **end_str--;**\\n- end_str 포인터를 왼쪽으로 한 칸 이동시킵니다.\\n- 처음에는 end_str이 str[7]을 가리키고 있기 때문에, 한 번 실행하면 end_str은 str[6]을 가리키게 됩니다.\\n\n- **반복문 종료**\\n- fir_str이 end_str과 같거나 end_str이 fir_str을 지나면 더 이상 반복하지 않음.\\n- 최종 문자열은 **\"HGFEDCBA\"로 뒤집힘.**\\n\n\\n\n• 3. 문자 출력\\n\n\\n\n- **i=1부터 시작하여 i를 2씩 증가시키면서 문자 출력.**\\n- **strlen(str) → 문자열 \"ABCDEFGH\"의 길이 8을 반환**\\n- **GECA 출력**",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_448",
      "title": "아래 그림에서의 네트워크에서 라우터를 통한 할당 가능한 2번, 4번, 5번의 IP를 보기에서 찾아 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "2) 192.168.35.72\n4) 129.200.8.249\n5) 192.168.36.249",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "2번 IP 정답 : 192.168.35.72\\n\n\\n\n1번 IP : 192.168.35.3/24\\n• 서브넷 마스크가 255.255.255.0이므로, 이 네트워크의 범위는 192~223 사이의 IP 주소 범위를 가지므로 2번 IP의 범위는 192.168.35.0부터 192.168.35.255까지입니다.\\n• 따라서 129.200.8.0와 129.200.8.249와 192.168.36.0와 192.168.36.249는 정답에서 제외됩니다.\\n\n• 네트워크 주소와 브로드캐스트 주소\\n• 0과 255는 특정한 의미를 가지고 있어 실제로 사용되지 않는 주소입니다.\\n• 따라서 192.168.35.0은 네트워크 주소이므로 정답에서 제외됩니다.\\n\n\\n\n4번 IP 정답: 129.200.8.249\\n\n\\n\n3번 IP : 129.200.10.16/22\\n\n• **서브넷 마스크 구하기**\\n• 서브넷 마스크가 255.255.252.0\\n• IPv4 주소는 32비트이므로, /22는 앞의 22비트가 네트워크 주소를 의미하고, 나머지 10비트가 호스트 부분\\n• 서브넷 마스크는 앞의 22비트는 1, 나머지 10비트는 0으로 채워짐.\\n• 255는 모든 비트가 1인 상태, 0은 모든 비트가 0인 상태\\n• /22를 8비트씩 나누어 보면\\n  - 8비트(첫 번째 옥텟): 11111111 (255)\\n  - 8비트(두 번째 옥텟): 11111111 (255)\\n  - 6비트(세 번째 옥텟): 11111100 (252)\\n  => 11111100을 십진수로 변환 = 252\\n  - 0비트(네 번째 옥텟): 00000000 (0)\\n\n\\n\n• **네트워크 주소 구하기**\\n• 네트워크 주소는 IP 주소와 서브넷 마스크의 AND 연산을 통해 구합니다.\\n• 10(IP 주소)과 252(서브넷 마스크) 이진법 : 10 -> 00001010 / 252 -> 11111100\\n  00001010 (IP 주소)\\n  11111100 (서브넷 마스크)\\n  -----------------\\n  00001000 (네트워크 주소)\\n• 00001000 십진법 -> 8 따라서 네트워크 주소는 129.200.8.0\\n\n\\n\n• **브로드캐스트 주소 구하기**\\n• 브로드캐스트 주소는 네트워크 주소의 호스트 부분을 모두 1로 설정하여 계산합니다.\\n  00001000 (네트워크 주소)\\n  00001011 (브로드캐스트 주소)\\n• 00001011 십진법 -> 11 따라서 브로드캐스트 주소 129.200.11.255\\n• 이 네트워크의 범위는 129.200.8.0부터 129.200.11.255까지입니다.\\n• 정답 후보인 129.200.8.0와 129.200.8.249 중 129.200.8.0은 네트워크 주소로 실제로 사용되지 않는 주소입니다.\\n• 따라서 정답은 129.200.8.249\\n\n\\n\n5번 IP 정답: 192.168.36.249\\n\n\\n\n6번 IP : 192.168.36.24/24\\n• 서브넷 마스크가 255.255.255.0이므로, 이 네트워크의 범위는 192.168.36.0부터 192.168.36.255까지입니다.\\n• 192.168.36.0은 네트워크 주소이고, 192.168.36.255는 브로드캐스트 주소이므로 192.168.36.0은 정답 제외\\n• 범위에 속해 할당 가능한 192.168.36.249가 정답입니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_449",
      "title": "해당 표에서 나타나고 있는 정규형은 무엇인가?",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "제 3정규형",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• **제3정규형(3NF) 만족**\\n\n\\n\n• 이행적 종속 없음\\n• 강사번호는 고객아이디와 강좌명에 의해 결정되며, 이는 기본 키에 종속된 속성입니다.\\n• 강사번호가 고객아이디와 강좌명에만 종속되고, 다른 비기본키 속성에 의존하지 않는다는 것입니다.\\n• 따라서, 이행적 종속이 존재하지 않으며, 제3정규형을 만족합니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_450",
      "title": "아래의 내용에서 설명하는 네트워크 용어를 영문 약자로 작성하시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "OSPF(Open Shortest Path First)",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• 링크 상태 알고리즘(**Link-State** 방식)은 네트워크 내 각 라우터가 자신과 연결된 다른 라우터들과의 **링크 상태 정보**를 주고받으며 네트워크의 **최단 경로**를 계산하는 방식입니다.\\n\n• 이 방식에서는 각 라우터가 네트워크의 전체 맵을 유지하고, 이를 기반으로 최적의 경로를 결정합니다.\\n\n\\n\n• **컨버전스 시간**은 네트워크 변화가 발생한 후, 모든 라우터가 새로운 경로를 일관되게 반영할 때까지 걸리는 시간입니다.\\n\n• 빠른 컨버전스는 네트워크 안정성을 높이는 데 중요한 요소입니다.\\n\n\\n\n• **라우팅 루프**는 네트워크 내에서 라우팅 정보가 순환하면서 패킷이 무한히 돌아가는 현상을 말합니다.\\n\n• 즉, 목적지를 찾지 못하고 끊임없이 순환하는 현상입니다.\\n\n\\n\n• **OSPF(Open Shortest Path First)**는 내부 라우팅 프로토콜로, **링크 상태 알고리즘**을 사용하여 대규모 네트워크에서 빠르고 안정적인 경로 계산을 제공합니다.\\n\n• OSPF는 네트워크의 변화에 대해 빠르게 **컨버전스**되며, **라우팅 루프**를 방지하는 특성이 있습니다.\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_451",
      "title": "다음은 조인(JOIN)에 대한 설명이다. 각 설명에 대한 답을 <보기>에서 찾아 작성하시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1. 세타 조인 / 2. 동등 조인 / 3. 자연 조인",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• 조인(**JOIN**)은 데이터베이스에서 두 개 이상의 테이블을 연결하여 원하는 데이터를 추출하는 방법입니다.\\n\n\\n\n• **세타 조인(θ Join)**은 조인에 참여하는 두 릴레이션(테이블)의 속성 값을 비교하여 조건을 만족하는 튜플(행)만 반환하는 방식입니다.\\n\n• 즉, 단순히 = (등호)뿐만 아니라 >, <, >=, <=, != 등의 연산자를 사용할 수 있는 조인입니다.\\n\n• (1)번 문장에서 \"조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환\"한다고 되어 있으므로, 세타 조인이 정답입니다.\\n\n\\n\n• **동등 조인(Equi Join)**은 세타 조인의 일종으로, 비교 조건이 정확하게 = (등호)로만 이루어진 조인입니다.\\n\n• 즉, 같은 값을 가진 속성끼리만 조인을 수행합니다.\\n\n• (2)번 문장에서 \"조건이 정확하게 '=' 등호로 일치하는 결과를 반환\"한다고 했으므로, 동등 조인이 정답입니다.\\n\n\\n\n• **자연 조인(Natural Join)**은 동등 조인과 비슷하지만, 중복된 속성을 제거하는 차이점이 있습니다.\\n\n• 즉, 조인 조건이 같은 속성을 자동으로 찾아 조인하며, 중복된 속성을 하나만 남깁니다.\\n\n• (3)번 문장에서 \"(2)번 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과\"라고 했으므로, 자연 조인이 정답입니다.\\n\n\\n\n• **외부 조인**은 조인 조건을 만족하지 않는 튜플(행)도 포함하여 결과를 반환하는 조인 방식입니다.\\n\n• 일반적으로 **LEFT OUTER JOIN**(왼쪽 외부 조인), **RIGHT OUTER JOIN**(오른쪽 외부 조인), **FULL OUTER JOIN**(완전 외부 조인)으로 나뉩니다.\\n\n\\n\n• **세미 조인**은 한 테이블의 일부 데이터만 가져오지만, 실제 조인을 수행하는 것이 아니라 서브쿼리를 활용하여 존재 여부만 확인하는 조인 방식입니다.\\n\n• 즉, 조인을 하되 두 번째 테이블의 데이터는 결과에 포함되지 않고, 첫 번째 테이블에서 해당 조건을 만족하는 데이터만 출력됩니다.\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_452",
      "title": "페이지 교체 알고리즘으로 LRU와 LFU 알고리즘을 사용하고 페이지 참조 순서는 보기와 같다. 이 경우 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘에서 발생하는 페이지 부재 횟수를 작성하시오.\n단, 초기에는 기억장치가 모두 비어 있다고 가정한다.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "LRU: 6 / LFU: 6",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "1. LRU 알고리즘 적용\\n\n• 메모리 프레임 개수: **3개**\\n\n• 페이지 요청 순서: **1, 2, 3, 1, 2, 4, 1, 2, 5, 7**\\n\n• 총 페이지 부재 횟수: **6회**\\n\n\\n\n2. LFU 알고리즘 적용\\n\n• 메모리 프레임 개수: **3개**\\n\n• 페이지 요청 순서: **1, 2, 3, 1, 2, 4, 1, 2, 5, 7**\\n\n• 총 페이지 부재 횟수: **6회**\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_453",
      "title": "아래 JAVA 코드의 실행 순서를 중복 번호없이 작성하시오. (실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( ) )",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "6 3 1 7 2",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class Parent {\n    int x, y;\n \n    Parent(int x, int y) { ①\n        this.x=x;\n        this y=y;\n    }\n \n    int getT() { ②\n        return x*y;\n    }\n}\n \n \n \n​class Child extend Parent {\n    int x;\n \n    Child (int x) { ③\n        super(x+1, x);\n        this.x=x;\n    }\n \n    int getT(int n){ ④\n        return super.getT()+n;\n    }\n}\n \n \n \nclass Main {\n    public static void main(String[] args) { ⑤\n        Parent parent = new Child(3); ⑥\n        System.out.println(parent.getT()); ⑦\n    }\n}",
      "answer": 1,
      "explanation": {
        "text": "1. main 메서드 실행 (_5_)\\n• **프로그램이 시작되면서 main 메서드가 실행됩니다.**\\n\n\\n\n2. Child 객체 생성 (_6_)\\n• **Child 클래스의 생성자가 호출됩니다.**\\n• **매개변수 3이 Child(int x) 생성자의 x에 전달됩니다.**\\n• **Parent 타입의 변수 parent가 자식 클래스의 객체 Child(3)를 참조합니다.**\\n• **parent 변수는 Parent 타입이지만, 실제로 참조하는 객체는 Child입니다.**\\n• **따라서 부모 클래스의 기능만 사용할 수 있지만, 오버라이딩된 메서드는 Child의 것이 실행됩니다.**\\n\n\\n\n3. Child 생성자 실행 (_3_)\\n• **6번 코드(new Child(3))가 실행되어 매개변수 3이 Child(int x)의 x로 전달됩니다.**\\n• **super()는 부모 클래스(Parent)의 생성자를 호출하는 코드입니다.**\\n• **여기서는 super(x + 1, x);가 실행되면서 Parent의 생성자가 호출됩니다.**\\n• **x + 1 → 3 + 1 = 4**\\n• **x → 3**\\n• **super(4, 3);가 실행되며 Parent 클래스의 x = 4, y = 3으로 초기화됩니다.**\\n• Parent(int x, int y) {\\n• this.x = x;  // x = 4\\n• this.y = y;  // y = 3\\n• }\\n• **여기서 this.x는 Child 클래스의 인스턴스 변수 x를 의미합니다.**\\n• **현재 상태:**\\n• **Child 클래스의 x → 3**\\n• **Parent 클래스의 x → 4**\\n• **Parent 클래스의 y → 3**\\n\n\\n\n4. Parent 생성자 실행 (_1_)\\n• **3번 코드가 실행되어, super(4, 3);이 실행되면서 Parent(4, 3) 생성자가 호출됨**\\n• **this.x는 Parent 클래스의 멤버 변수 x를 의미합니다.**\\n• **여기서 this는 현재 객체(Parent 객체)를 가리킵니다.**\\n• **즉, 전달된 매개변수 x 값을 Parent 클래스의 x 변수에 저장합니다.**\\n• **this.y = y를 실행하면서 매개변수 y 값을 Parent 클래스의 멤버 변수 y에 저장합니다.**\\n• **현재 상태:**\\n• **Parent 클래스의 x = 4**\\n• **Parent 클래스의 y = 3**\\n\n\\n\n5. 메서드 호출 (_7_)\\n• **parent.getT()의 결과 값을 계산한 후 콘솔에 출력하는 역할을 합니다.**\\n• **parent는 Parent 타입으로 선언되었기 때문에 Parent 클래스의 getT() 메서드(②)가 호출됩니다.**\\n\n\\n\n6. getT 메서드 실행 (_2_)\\n• **현재 parent 객체는 new Child(3)을 통해 생성되었습니다.**\\n• **이 과정에서 Parent의 x와 y 값은 다음과 같이 초기화되었습니다.**\\n• Parent(int x, int y) {  // super(x+1, x) → super(4, 3)\\n• this.x = x;  // x = 4\\n• this.y = y;  // y = 3\\n• }\\n• **따라서 getT() 실행 시, 4 * 3 = 12 즉, 12가 반환됩니다.**\\n• **최종적으로, System.out.println(12);이므로 12가 출력됩니다.**\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_454",
      "title": "다음 C 프로그램의 실행결과를 쓰시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "9981 and 2795.10",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include <stdio.h>\n\nstruct BankAcc {\n    int accNum;\n    double bal;\n};\n\ndouble sim_pow(double base, int year) {\n    double r = 1.0;\n    for (int i = 0; i < year; i++) {\n        r = r * (1.0 + base);\n    }\n    return r;\n}\n\nvoid initAcc(struct BankAcc *acc, int x, double y) {\n    acc->accNum = x;\n    acc->bal = y;\n}\n\nvoid test01(struct BankAcc *acc, double en) {\n    if (en > 0 && en < acc->bal) {\n        acc->bal -= en;\n    } else {\n        acc->bal += en;\n    }\n}\n\nvoid test02(struct BankAcc *acc) {\n    acc->bal = acc->bal * sim_pow(0.1, 3);\n}\n\nint main() {\n    struct BankAcc myAcc;\n    initAcc(&myAcc, 9981, 2200.0);\n    test01(&myAcc, 100.0);\n    test02(&myAcc);\n    printf(\"%d and %0.2f\", myAcc.accNum, myAcc.bal);\n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "1. main 함수\\n• **프로그램 실행 시작점. main()에서 순서대로 호출되며, 실행 흐름을 따라가면서 결과를 예측해야 한다.**\\n\n\\n\n2. BankAcc 구조체 변수 선언\\n• **myAcc라는 구조체 변수를 선언한다.**\\n• **BankAcc라는 구조체를 정의한다.**\\n• **accNum: 계좌번호를 저장하는 정수형 변수.**\\n• **bal: 계좌 잔액을 저장하는 실수형 변수.**\\n\n\\n\n3. 계좌 초기화 (initAcc)\\n• **myAcc의 주소를 넘겨서 초기화 실행.**\\n• **여기서 &myAcc는 myAcc 구조체 변수의 주소값을 의미합니다.**\\n• **struct BankAcc *acc를 입력받아 accNum과 bal을 초기화하는 함수.**\\n• **initAcc() 함수의 매개변수로 struct BankAcc *acc가 선언되어 있습니다.**\\n• **이 함수에서 acc는 struct BankAcc 타입의 구조체 변수를 가리키는 포인터입니다.**\\n• **즉, acc는 myAcc의 주소를 가리키는 포인터가 되는 것입니다.**\\n• **-> 연산자는 포인터를 이용해 구조체 멤버에 접근하는 연산자입니다.**\\n• **initAcc() 함수 내에서는 -> 연산자를 사용해 멤버 변수에 접근하고 있습니다.**\\n• **myAcc.accNum = 9981, myAcc.bal = 2200.0**\\n\n\\n\n4. 입출금 처리 함수 (test01)\\n• **bal: 계좌 잔액을 저장하는 실수형 변수**\\n• **en > 0 && en < acc->bal 조건이 참이면 acc->bal -= en;**\\n• **(출금을 의미하는 식: 잔액에서 en을 뺌)**\\n• **조건이 거짓이면 acc->bal += en;**\\n• **(입금을 의미하는 식: 잔액에 en을 더함)**\\n• **test01(&myAcc, 100.0); 실행**\\n• **myAcc.bal = 2200.0 → 초기 잔액**\\n• **100.0 > 0 && 100.0 < 2200.0 → 조건 만족 → 출금 수행**\\n• **myAcc.bal = 2200.0 - 100.0 = 2100.0 → 출금 후 잔액**\\n\n\\n\n5. 이자 계산 함수 (test02)\\n• **sim_pow(0.1, 3)의 결과값을 구해서 현재 계좌 잔액(acc->bal)에 곱하여 업데이트**\\n• **bal: 계좌 잔액을 저장하는 실수형 변수**\\n• [참고] **복리 이자 공식: 최종금액 = 원금 × (1+이자율)^기간**\\n• **base: 이자율 (0.1 → 10%) / year: 기간 (3년) / r: 누적된 복리 값**\\n• **초기값: r = 1.0**\\n• **첫 번째 반복 (i = 0) → r = 1.0 × (1.0 + 0.1) = 1.1**\\n• **두 번째 반복 (i = 1) → r = 1.1 × (1.0 + 0.1) = 1.21**\\n• **세 번째 반복 (i = 2) → r = 1.21 × (1.0 + 0.1) = 1.331**\\n• **반환값: 1.331**\\n\n\\n\n6. 출력 실행 ()\\n• **형식 지정**\\n• **%d → 정수형(int) 출력**\\n• **%0.2f → 소수점 둘째 자리까지 실수형(double) 출력**\\n• **\" and \" → 문자열 그대로 출력**\\n• **myAcc.accNum = 9981**\\n• **myAcc.bal = 2795.10**\\n• **출력값: 9981 and 2795.10**\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_455",
      "title": "다음 파이썬 코드에 대한 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_Python",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Seynaau",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"] \nstr = \"S\"\n \nfor i in a:\n    str = str + i[1]\n \nprint(str)",
      "answer": 1,
      "explanation": {
        "text": "1. 리스트(List)\\n• **리스트는 대괄호([])로 표현하며, 여러 값을 담을 수 있는 자료형입니다.**\\n• **리스트의 각 요소는 인덱스를 사용해 접근할 수 있습니다. 인덱스는 0부터 시작합니다.**\\n• **a[0]은 \"Seoul\"이고, a[1]은 \"Kyeonggi\"입니다.**\\n\n\\n\n2. for ... in 문\\n• **for ... in 문은 리스트, 문자열, 튜플, 딕셔너리처럼 여러 개의 값을 담고 있는 자료형(반복 가능한 객체, iterable)을 하나씩 꺼내서 반복 작업을 할 때 사용하는 문법입니다.**\\n• **변수 : 반복할 자료 안에서 현재 꺼낸 값이 저장되는 변수입니다.**\\n• **반복할_자료 : 리스트, 문자열, range 등 반복 가능한 자료형입니다.**\\n• **실행할_코드 : 반복할 때마다 실행되는 코드입니다.**\\n• **리스트 a에는 도시 이름들이 들어 있습니다.**\\n• **for i in a:는 리스트 a에서 하나씩 값을 꺼내서 변수 i에 저장합니다.**\\n• **i에는 반복할 때마다 \"Seoul\", \"Kyeonggi\" ... 와 같이 각 도시 이름이 차례로 저장되고, 해당 값을 사용할 수 있습니다.**\\n• **i[1]은 현재 문자열 i의 두 번째 문자입니다. 이 문자를 기존의 str 문자열 끝에 이어붙이는 방식입니다.**\\n\n\\n\n3. 최종 출력\\n• **위의 반복문을 거치면 str이라는 변수 안에 \"Seynaau\" 문자열이 저장됩니다.**\\n• **print()는 괄호 안의 값을 화면에 출력합니다. 따라서 \"Seynaau\"가 출력됩니다.**\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_456",
      "title": "아래 보기의 SQL 문장과 테이블을 참고하여 출력 값을 표로 작성하시오.",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "B \na\nb",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "SELECT\n    B\nFROM\n    R1\nWHERE\n    C IN (SELECT C FROM R2 WHERE D=\"k\");",
      "answer": 1,
      "explanation": {
        "text": "1. 서브쿼리 (Subquery)와 메인쿼리 (Main Query)\\n\n• SQL에서 **서브쿼리(Subquery)**는 쿼리 안에 포함된 또 다른 쿼리로, **메인쿼리(Main Query)**가 실행되기 전에 먼저 수행되어 그 결과를 메인쿼리에 전달합니다.\\n\n• 주로 **WHERE**, **FROM**, **SELECT** 절에서 사용되며, 복잡한 조건이나 필터링을 효율적으로 처리할 수 있게 해줍니다.\\n\n• 서브쿼리는 괄호 **()**로 감싸며, 메인쿼리가 사용할 데이터를 먼저 추출하는 데 사용됩니다.\\n\n• 결과적으로, 메인쿼리의 조건을 동적으로 구성할 수 있도록 도와줍니다.\\n\n\\n\n2. IN 연산자 (IN Operator)\\n\n• **IN 연산자**는 SQL에서 특정 컬럼의 값이 지정된 여러 값 중 하나와 일치하는지를 비교할 때 사용하는 조건 연산자입니다.\\n\n• 여러 개의 값 중 하나라도 일치하면 조건을 만족합니다.\\n\n• 특히 **서브쿼리**와 함께 사용할 때 유용하며, 복잡한 조건을 쉽게 처리할 수 있습니다.\\n\n• '공학' 계열에 속한 학과의 학생을 찾는 쿼리입니다.\\n\n• 서브쿼리 **(SELECT C FROM R2 WHERE D = 'k')**가 먼저 실행되어 D = 'k'인 행의 C 값들을 추출합니다.\\n\n• => 결과: 'x', 'y'\\n\n• 메인쿼리는 R1 테이블에서 C가 'x' 또는 'y'인 행의 B 값을 가져옵니다.\\n\n• (C 속성의 값이 서브쿼리 결과값과 동일한 값의 B값을 가져옵니다)\\n\n• => 결과: 'a', 'b'\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_457",
      "title": "아래는 애플리케이션테스트 관리에 대한 내용이다. 설명하는 답을 보기에서 골라 작성하시오.",
      "subject": "애플리케이션테스트 관리",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ㄹ.변경 조건/결정 커버리지",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• **MC/DC**는 구조 기반 테스트 기법 중 하나로, 고신뢰성 소프트웨어(**항공**, **의료** 등)에서 가장 강력하게 요구되는 테스트 커버리지이다.\\n\n• 이 기법은 각 조건이 전체 결과에 **독립적으로 영향을 미치는지**를 확인하는 것이 핵심이다. 즉, 조건 **A**가 참 또는 거짓으로 바뀔 때 **결정 결과**가 실제로 바뀌는지를 테스트해야 한다.\\n\n• \"모든 분기와 조건의 조합을 고려하나...\" → 모든 조합은 **MCC**, 하지만 중요한 조합만 선택 → **MC/DC**\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_458",
      "title": "다음 설명에 해당하는 보안 용어를 보기에서 고르시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ㅅ. Rootkit",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "**Rootkit**은 시스템에 침투한 해커가 자신의 존재를 숨기고, 최고 관리자 권한(**root**)을 획득하여 시스템을 지속적으로 장악할 수 있도록 만든 악성 도구 모음이다.\\n\n\\n\n• **Rootkit = 은폐 + 최고 권한 탈취 + 시스템 통제**\\n\n• 탐지를 피하면서 지속적으로 시스템에 침투하고 통제하기 위한 도구 집합\\n\n• 보안 위협 중 가장 교묘하고 탐지 어려운 유형\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_459",
      "title": "다음 Java 코드를 보고 알맞은 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_JAVA",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "9",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "class classOne {\n    int a, b;\n \n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n \n    public void print() {\n        System.out.println(a + b);\n    }\n \n}\nclass classTwo extends classOne {\n    int po = 3;\n    \n    public classTwo(int i) {\n        super(i, i+1);\n    }\n \n    public void print() {\n        System.out.println(po*po);\n    }\n}\n \npublic class main {  \n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}\n",
      "answer": 1,
      "explanation": {
        "text": "1. 클래스 구조와 상속 관계\\n• **자식 클래스가 부모 클래스의 속성(필드)과 기능(메서드)을 물려받는 것을 상속(Inheritance)이라고 합니다.**\\n• **자바에서는 extends 키워드를 사용해 상속을 구현합니다.**\\n• **classTwo는 classOne을 상속받은 클래스이므로, 부모 클래스의 a, b 필드와 print() 메서드를 물려받습니다.**\\n• **단, 자식 클래스에서 print() 메서드를 오버라이딩(Overriding)하면, 자식 클래스의 메서드가 우선적으로 사용됩니다.**\\n\n\\n\n2. main 메서드와 다형성\\n• **이 코드는 자식 클래스인 classTwo 객체를 부모 클래스 타입인 classOne 변수에 담은 것입니다. 이를 업캐스팅(Upcasting)이라고 합니다.**\\n• **즉, 변수 one의 타입은 classOne이지만, 실제 생성된 객체는 classTwo입니다.**\\n• **print() 메서드는 classTwo에서 오버라이딩 되어 있습니다.**\\n• **즉, 부모 클래스에도 같은 이름의 메서드가 존재하지만, 자식 클래스에서 재정의한 메서드가 실행됩니다.**\\n• **자바에서는 메서드 호출 시 변수의 타입이 아닌, 실제 객체의 타입을 기준으로 메서드를 실행합니다.**\\n• **따라서 one.print();를 실행하면 classTwo의 print()가 호출됩니다.**\\n\n\\n\n3. classTwo 클래스 내부 동작\\n• **classTwo는 int po = 3이라는 새로운 필드를 정의하고 있습니다.**\\n• **생성자에서 super(i, i + 1);을 통해 부모 클래스의 생성자를 호출합니다. 예를 들어 i = 10이면 a = 10, b = 11이 됩니다.**\\n• **그러나 이 문제에서 중요한 건 print() 메서드가 자식 클래스에서 오버라이딩 되었다는 점입니다.**\\n• **classTwo의 print()는 po * po를 출력하므로, po = 3일 때 3 * 3 = 9가 출력됩니다.**\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_460",
      "title": "다음 설명에 해당하는 보안 용어를 보기에서 고르시오.",
      "subject": "소프트웨어 개발 보안 구축",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "ㅅ. APT",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "• **APT(지능형 지속 위협)**은 특정 기업, 기관을 목표로 장기간 동안 은밀하고 지속적으로 침투 및 정보 탈취를 시도하는 정교한 공격 기법이다.\\n\n\\n\n• **APT = Advanced Persistent Threat**\\n\n• 특정 조직을 대상으로 사전 조사부터 침투, 정보 유출까지 체계적으로 수행\\n\n• 장기적·지속적·정교한 위협 공격\\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_461",
      "title": "아래와 같은 테이블이 있을때, 다음 SQL 문의 결과는?",
      "subject": "SQL 응용",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "SELECT \n    COUNT(*) \nFROM \n    TABLE \nWHERE \n    EMPNO > 100 \nAND \n    SAL >= 3000 OR EMPNO = 200",
      "answer": 1,
      "explanation": {
        "text": "1. COUNT(*) 함수\\n\n• **COUNT(*)**는 테이블에서 조건을 만족하는 행(row)의 개수를 세는 집계 함수입니다.\\n\n• **WHERE** 절과 함께 사용하면, 조건을 만족하는 행만 세기 때문에 이 조건을 정확히 이해하는 것이 핵심입니다.\\n\n\\n\n2. WHERE 절 조건 분석: SQL의 연산자 우선순위에 따라 **AND**가 **OR**보다 먼저 평가됩니다.\\n \n\\n\n3. 조건 대입 및 최종 결과\\n\n• 이제 각 행에 대해 조건을 적용해 봅니다.\\n\n• **EMPNO=100**: 두 조건 모두 불만족 → 제외\\n\n• **EMPNO=200**: (**EMPNO > 100** AND **SAL >= 3000**)도 만족, **EMPNO = 200**도 만족 → 포함\\n\n• **EMPNO=300**: EMPNO는 조건을 만족하지만 SAL은 만족하지 않음 → 제외\\n\n\\n\n조건을 만족하는 행은 오직 **EMPNO=200** 한 행입니다. 따라서 **COUNT(*)**는 이 1개의 행을 세고, 결과는: **1**\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_462",
      "title": "다음 C언어 코드의 알맞는 출력 값을 작성하시오.",
      "subject": "프로그래밍 언어 활용_실기_C",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Nd sc 1",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "#include<stdio.h>\n#include<ctype.h>\n \nint main(){\n    char*p = \"It is 8\";\n    char result[100];\n    int i;\n \n    for(i=0; p[i]!='\\0'; i++){\n        if(isupper(p[i]))\n            result[i] = (p[i]-'A'+5)% 25 + 'A';\n        else if(islower(p[i]))\n            result[i] = (p[i]-'a'+10)% 26 + 'a';\n        else if(isdigit(p[i]))\n            result[i] = (p[i]-'0'+3)% 10 + '0';\n        else if(!(isupper(p[i]) || islower(p[i]) || isdigit(p[i])))    \n            result[i] = p[i];\n    }\n \n    result[i] = '\\0';\n    printf(\"%s\\n\",result);\n \n    return 0;\n}",
      "answer": 1,
      "explanation": {
        "text": "1. main 함수 변수 초기화\\n• int main()\\n• C 프로그램의 진입점(entry point)인 함수입니다.\\n• 프로그램 실행 시 가장 먼저 호출되며, 전체 흐름을 제어하는 시작점입니다.\\n\n• char* p = \"It is 8\";\\n• p는 문자열 리터럴 \"It is 8\"을 가리키는 문자 포인터입니다.\\n• 문자열 리터럴은 메모리에 연속적으로 저장됩니다.\\n• 포인터 p에는 문자열의 첫 번째 문자 'I'가 저장된 메모리 주소가 저장됩니다.\\n• 포인터는 문자가 저장된 위치(주소)를 저장합니다.\\n• p[0]은 'I', p[1]은 't'와 같이 배열처럼 접근할 수 있습니다.\\n• 문자열 리터럴은 읽기 전용(Read-only)으로 취급됩니다.\\n\n• char result[100];\\n• result는 암호화된 결과 문자열을 저장하기 위한 문자 배열입니다.\\n• char형 데이터를 최대 100개까지 저장할 수 있는 배열입니다.\\n• C 언어에서 문자열은 마지막에 반드시 널 문자('\\0')를 포함해야 합니다.\\n\n• int i;\\n• for 반복문에서 인덱스로 사용할 정수형 변수입니다.\\n\n\\n\n2. for문을 이용한 문자 순회 및 변환 처리\\n\n• **for문 개요**\\n• for(i = 0; p[i] != '\\0'; i++)\\n• 이 반복문은 문자열 p의 각 문자를 순차적으로 순회합니다.\\n• 조건식 p[i] != '\\0'은 문자열 끝(널 문자)까지 반복하라는 의미입니다.\\n\n\\n\n• **문자 판별 및 변환 처리**\\n• isupper(int c) : 문자가 대문자 알파벳인지 확인\\n• islower(int c) : 문자가 소문자 알파벳인지 확인\\n• isdigit(int c) : 문자가 숫자 문자(0~9)인지 확인\\n\n\\n\n• **for문 처리**\\n• ASCII 표에 따라 문자 변환을 수행합니다.\\n• 첫 번째 문자 'I' → 대문자 변환: 'N'\\n• 두 번째 문자 't' → 소문자 변환: 'd'\\n• 세 번째 문자 ' ' → 공백 복사\\n• 네 번째 문자 'i' → 소문자 변환: 's'\\n• 다섯 번째 문자 's' → 소문자 변환: 'c'\\n• 여섯 번째 문자 ' ' → 공백 복사\\n• 일곱 번째 문자 '8' → 숫자 변환: '1'\\n\n\\n\n3. 출력\\n• 문자열 끝에 널 문자('\\0')를 추가합니다.\\n• printf(\"%s\", result);로 문자열을 출력합니다.\\n• %s : 문자열 출력\\n• %d : 정수 출력\\n• %c : 문자 하나 출력\\n• \\n은 줄바꿈을 의미합니다.\\n• 최종 결과: Nd sc 1이 출력됩니다.\\n\n",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    },
    {
      "id": "ques_463",
      "title": "다음 설명에 해당하는 디자인 패턴은 무엇인가?",
      "subject": "프로그래밍 언어 활용_실기",
      "questionType": "기출",
      "date": "",
      "choice1": {
        "text": "Abstract Factory",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice2": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice3": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "choice4": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "desc": {
        "text": "",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "code": "",
      "answer": 1,
      "explanation": {
        "text": "추상 팩토리 패턴(Abstract Factory)은 생성(Creational) 디자인 패턴에 속하며, 서로 관련 있는 객체들을 일관된 방식으로 생성할 수 있는 인터페이스를 제공하는 것이 주요 목적입니다. 이 패턴은 구체 클래스에 대한 의존성을 줄이고, 제품군 단위로 객체들을 생성할 수 있도록 설계되었습니다. 이러한 특징 덕분에 관련된 객체들을 한 세트로 묶어서 사용할 수 있으며, *키트(Kit) 패턴\"이라는 별칭으로도 불립니다.",
        "images": [
          {
            "data": "",
            "filename": ""
          }
        ]
      },
      "viewCount": 0,
      "version": 1
    }
  ]
}
